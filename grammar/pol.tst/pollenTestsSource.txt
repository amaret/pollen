================
List of pollen tests
================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/amaret/cc.arduino/Duemilanove.p
>>> test source:
package cc.arduino

from mcu.atmel.atmega328p import Mcu

# Rename mcu pins to names on board
from Mcu import PB4	as D12
from Mcu import PB5 as D13

from pollen.parts import Led{false} as Led

composition Duemilanove {

	export Mcu	
    export Led
    
   	# Available Digital IO Lines
    export D12
    export D13		
    
	host Duemilanove() {
		Mcu.setSystemFrequency(16000000)
        Led.bindPin(D13)
	}
}====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/amaret/cc.arduino/Environment.p
>>> test source:
package cc.arduino

import Duemilanove as Board
from Board import Led
from Board import Mcu
from Mcu import GlobalInterrupts
from Mcu import TimerMilli8BitTimer0 as TD

from pollen.time import Time
from pollen.events import Events

composition Environment {	# This should extend Board when composition inheritance exits!

	export GlobalInterrupts
	export Led
	export Mcu
	export Mcu.reset
	export Mcu.wait
	export Events.run
	export Events.post
	export Events.postFromInterrupt	
	
	host Environment() {
		Events.bindGlobalInterrupts(GlobalInterrupts)
		Time.bindGlobalInterrupts(GlobalInterrupts)
		Time.bindTimerDriver(TD)
	}
}====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/amaret/distro.arduino/Board.p
>>> test source:
package distro.arduino

from mcu.atmel.atmega328p import Mcu


from Mcu import PB4	as D12
from Mcu import PB5 as D13

from Mcu import TimerMilli8BitTimer0 as Timer0
from Mcu import Uart 

from pollen.parts import Led{false} as Led

composition Board {

	export Mcu
	export Timer0
	export Uart
	
    export Led
    
    export D12
    export D13		# Led pin is exposed on arduino
    
	host Board() {
		Mcu.setSystemFrequency(16000000)
        Led.bindPin(D13) #(D12)
	}
}====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/amaret/distro.arduino/Distro.p
>>> test source:
package distro.arduino

import Board
from Board import Mcu
from Board import Led
from Board import Pin0
from Board import Timer0
from Board import Uart
from Mcu import GlobalInterrupts

from pollen.events import Events
from pollen.time import Time

composition Distro {

    export Led
    export Mcu
    export Pin0
    export Uart
                    
    host Distro() {
        Events.bindGlobalInterrupts(GlobalInterrupts)
        Time.bindGlobalInterrupts(GlobalInterrupts)
        Time.bindTimerDriver(Timer0)
        Uart.setBaud(57600)
    }
}
====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/amaret/distro.arduino/Lifecycle.p
>>> test source:
package distro.arduino

---

This module defines all the pollen lifecycle intrinsics

---

module Lifecycle {

	#
	# Invoked immediately after initialization of C runtime
	#
	pollen.reset() {
	
	}
	
	#
	# Invoked after every application module's target initializer has been invoked
	# and immediately before pollen.run is called.
	#
	pollen.ready() {
	
	}
	
	#
	# 
	#
	#pollen.shutdown(uint8 code) {
	#
	#}
	
	#
	# 
	#
	#pollen.hibernate(uint8 code) {
	#
	#}
}====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/amaret/distro.ti.launchpad/Board.p
>>> test source:
package distro.ti.launchpad

from mcu.ti.msp430g2231 import Mcu
from Mcu import P1_0 as Pin0

from pollen.parts import Led{false} as Led

composition Board {

	export Mcu
	export Pin0
    export Led
    
    host Board() {
        Led.bindPin(Pin0)
	}

}====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/amaret/distro.ti.launchpad/Distro.p
>>> test source:
package distro.ti.launchpad

from Board import Mcu
from Board import Pin0
from Mcu import GlobalInterrupts

from pollen.events import Events
from pollen.time import Time

composition Distro {

    export Mcu
    export Pin0
                    
    host Distro() {
        Events.bindGlobalInterrupts(GlobalInterrupts)
    }
}
====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/amaret/freescale.mma845x/MMA845x.p
>>> test source:

from pollen.interfaces import I2C

module MMA845x {

	const byte REG_STATUS = 0x00; //(R) Real time status
	const byte REG_OUT_X_MSB = 0x01; //(R) [7:0] are 8 MSBs of 10-bit sample
	const byte REG_OUT_X_LSB = 0x02; //(R) [7:6] are 2 LSBs of 10-bit sample
	const byte REG_OUT_Y_MSB = 0x03; //(R) [7:0] are 8 MSBs of 10-bit sample
	const byte REG_OUT_Y_LSB = 0x04; //(R) [7:6] are 2 LSBs of 10-bit sample
	const byte REG_OUT_Z_MSB = 0x05; //(R) [7:0] are 8 MSBs of 10-bit sample
	const byte REG_OUT_Z_LSB = 0x06; //(R) [7:6] are 2 LSBs of 10-bit sample
	const byte REG_SYSMOD = 0x0b; //(R) Current system mode
	const byte REG_INT_SOURCE = 0x0c; //(R) Interrupt status
	const byte REG_WHO_AM_I = 0x0d; //(R) Device ID (0x3A)
	const byte REG_XYZ_DATA_CFG = 0xe; //(R/W) Dynamic range settings
	const byte REG_HP_FILTER_CUTOFF = 0x0f; //(R/W) cut-off frequency is set to 16Hz @ 800Hz
	const byte REG_PL_STATUS = 0x10; //(R) Landscape/Portrait orientation status
	const byte REG_PL_CFG = 0x11; //(R/W) Landscape/Portrait configuration
	const byte REG_PL_COUNT = 0x12; //(R) Landscape/Portrait debounce counter
	const byte REG_PL_BF_ZCOMP = 0x13; //(R) Back-Front, Z-Lock trip threshold
	const byte REG_P_L_THS_REG = 0x14; //(R/W) Portrait to Landscape trip angle is 29 degree
	const byte REG_FF_MT_CFG = 0x15; //(R/W) Freefall/motion functional block configuration
	const byte REG_FF_MT_SRC = 0x16; //(R) Freefall/motion event source register
	const byte REG_FF_MT_THS = 0x17; //(R/W) Freefall/motion threshold register
	const byte REG_FF_MT_COUNT = 0x18; //(R/W) Freefall/motion debounce counter
	const byte REG_TRANSIENT_CFG = 0x1d; //(R/W) Transient functional block configuration
	const byte REG_TRANSIENT_SRC = 0x1e; //(R) Transient event status register
	const byte REG_TRANSIENT_THS = 0x1f; //(R/W) Transient event threshold
	const byte REG_TRANSIENT_COUNT = 0x20; //(R/W) Transient debounce counter
	const byte REG_PULSE_CFG = 0x21; //(R/W) ELE, Double_XYZ or Single_XYZ
	const byte REG_PULSE_SRC = 0x22; //(R) EA, Double_XYZ or Single_XYZ
	const byte REG_PULSE_THSX = 0x23; //(R/W) X pulse threshold
	const byte REG_PULSE_THSY = 0x24; //(R/W) Y pulse threshold
	const byte REG_PULSE_THSZ = 0x25; //(R/W) Z pulse threshold
	const byte REG_PULSE_TMLT = 0x26; //(R/W) Time limit for pulse
	const byte REG_PULSE_LTCY = 0x27; //(R/W) Latency time for 2nd pulse
	const byte REG_PULSE_WIND = 0x28; //(R/W) Window time for 2nd pulse
	const byte REG_ASLP_COUNT = 0x29; //(R/W) Counter setting for auto-sleep
	const byte REG_CTRL_REG1 = 0x2a; //(R/W) ODR = 800 Hz, STANDBY mode
	const byte REG_CTRL_REG2 = 0x2b; //(R/W) Sleep enable, OS Modes, RST, ST
	const byte REG_CTRL_REG3 = 0x2c; //(R/W) Wake from sleep, IPOL, PP_OD
	const byte REG_CTRL_REG4 = 0x2d; //(R/W) Interrupt enable register
	const byte REG_CTRL_REG5 = 0x2e; //(R/W) Interrupt pin (INT1/INT2) map
	const byte REG_OFF_X = 0x2f; //(R/W) X-axis offset adjust
	const byte REG_OFF_Y = 0x30; //(R/W) Y-axis offset adjust
	const byte REG_OFF_Z = 0x31; //(R/W) Z-axis offset adjust
	
	const byte FULL_SCALE_RANGE_2g = 0x0;
	const byte FULL_SCALE_RANGE_4g = 0x1;
	const byte FULL_SCALE_RANGE_8g = 0x2;
	
	uint8 i2c_addr = 0x1C # Address of the MMA8453 part. 0x1D is another common value
	int16 x, y, z
	bool dataMode = false
	host bool highResolutionData = true

	public setI2CAddr(uint8 address) {
		@i2c_addr = address
	}

	public dataMode(bool highRes, uint8 gScaleRange) {}

	public int16 x() { return @x }

	public int16 y() { return @y }

	public int16 z() { return @z }

	public update() {}

	regRead(byte reg, byte *buf, byte count = 1) {
	
	}
	
	regWrite(byte reg, byte val) {
	
	}
}====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/amaret/mcu.atmel.atmega/InterruptMeta.p
>>> test source:
---
	Interrupt meta module for AVR microcontrollers*
	
	*This module is GCC specific
---

from pollen.interfaces import Handler
from pollen.interfaces import Interrupt

meta {string name, string enableRegister, string enableBit, string clearRegister, string clearBit}

module InterruptMeta implements Interrupt {

	+{ #include <avr/io.h> }+
	+{ #include <avr/interrupt.h> }+
	
	+{ ISR( }+
	+{name}+
	+{ ) { }+
    	+{isr()}+
    +{;} }+ 

	public host setHandler(Handler.handle h) { @h = h }
	
	public setHandler(Handler.handle h) { @h = h }

	public enable() {
		+{enableRegister}+ |= (1 << +{enableBit}+)
	}

	public bool enabled() {
		return +{enableRegister}+ & (1 << +{enableBit}+)
	}

	public disable() {
		+{enableRegister}+ &= ~(1 << +{enableBit}+)
	}

	public clear() {
		+{clearRegister}+ &= ~(1 << +{clearBit}+)
	}
	
	#====================
	# Private members
	#====================
	Handler.handle h = 0
	
	isr() {
		if (h != null) { h() }
	}
}
====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/amaret/mcu.atmel.atmega328p/Atmega328p.p
>>> test source:
---

This module provides an ATMega328p specific implementation of the Mcu interface.

---

package mcu.atmel.atmega328p

from pollen.interfaces import Mcu as McuI

module Atmega328p implements McuI {

	public reset() {

	}

	public shutdown() {
	}
	
	public wait(uint32 us) {
		# one loop takes 4-5 cpu cycles
	    # THIS LOOP SHOULD BE GENERATED, GIVEN MCU FREQ,
	    # GENERATE ENOUGH nops SUCH THAT N*NOPS + 4 = (mcuFreq / 1000000)

		for (; us > 0; us--) {
	        +{ asm("nop") }+
	        +{ asm("nop") }+
	        +{ asm("nop") }+
	        +{ asm("nop") }+
	        +{ asm("nop") }+
	        +{ asm("nop") }+
	        +{ asm("nop") }+
	        +{ asm("nop") }+
	        +{ asm("nop") }+
	        +{ asm("nop") }+
	        +{ asm("nop") }+
		}
	}
	
	public nop() {
        +{ asm("nop") }+	
	}

	public host uint32 getSystemFrequency() { 
		return @sysFreq 
	}
	
	public uint32 getSystemFrequency() { 
		return @sysFreq 
	}
	
	public host setSystemFrequency(uint32 hz) {
		@sysFreq = hz
	}
	
	public setSystemFrequency(uint32 hz) {
		@sysFreq = hz
	}


	#==================================
	# Private data members 
	#==================================
	uint32 sysFreq

}
====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/amaret/mcu.atmel.atmega328p/GlobalInterrupts.p
>>> test source:
package mcu.atmel.atmega328p

from pollen.interfaces import GlobalInterrupts as GI

module GlobalInterrupts implements GI {

    +{ #include <avr/io.h>
       #include <avr/interrupt.h> }+

	public uint16 disable() {
    	uint16 key = +{SREG}+ & (1 << 7)
	    +{cli()}+
	    return key
	}

	public enable() {
    	+{sei()}+
	}
    
	public restore(uint16 key) {
    	if (key != 0) {
        	+{sei()}+
	    }
	    else {
    	    +{cli()}+
	    }
	}    
}====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/amaret/mcu.atmel.atmega328p/GpioMeta.p
>>> test source:
---

Meta module for AVR Gpio

---

package mcu.atmel.atmega328p

from pollen.interfaces import Gpio

meta { string port = "", string ddr = "", uint8 pin = 0 } module GpioMeta implements Gpio {

		+{ #include <avr/io.h> }+

		public set() { +{port}+ |= (1 << pin) }

		public clear() { +{port}+ &= ~(1 << pin) }
		
		# THIS FUNCTION IS WRONG! SHOULD BE PIN inside +{}+ not PORT	
		public bool get() { return (+{port}+ & (1 << pin)) ? true : false }

		public toggle()	{ +{port}+ ^= (1 << pin) }

		public makeInput()	{ +{ddr}+ &= ~(1 << pin) }

		public bool isInput() { return (+{ddr}+ & (1 << pin)) ? false : true }

		public makeOutput()	{ +{ddr}+ |= (1 << pin) }

		public bool isOutput() { return (+{ddr}+ & (1 << pin)) ? true : false }
	}
====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/amaret/mcu.atmel.atmega328p/I2C.p
>>> test source:
from pollen.interfaces import I2C as I2CI

#import McuLayout.PC4 as sdaPin
#import McuLayout.PC5 as sclPin

module I2C implements I2CI {

	# host Gpio sclPin
	# host Gpio sdaPin
	#host 
	uint32 slowestSlaveFrequency = 100000
	#host 
	uint32 mcuFrequency = 16000000 		# THIS MUST BE CHANGED!!

	#host setSlowestSlaveFrequency(uint32 freq) { }
	
	#const
	uint8 MT_SLA_ACK = 0x18
    uint8 MR_SLA_ACK = 0x40
    uint8 MT_DATA_ACK = 0x28
    uint8 START = 0x08
    uint8 RESTART = 0x10	

	+{ #include <avr/io.h> }+
    
    bool ready() {
	    return (+{TWCR}+ & (1 << +{TWINT}+)) ? true : false    	
    }
    
    I2C() {
		#sclPin.set()
    	#sclPin.makeOutput()
    	
		#sdaPin.set()
    	#sdaPin.makeOutput()
    }
    
    public enableAsMaster() { 
   	    uint32 sclFrequency = 0
    	uint8 prescaler = 0
    
    	# Ensure that TWI is not in power reduction
    	+{PRR &= ~(1<<PRTWI)}+
    
    	sclFrequency = ((mcuFrequency / slowestSlaveFrequency) - 16) / 2
    	while(sclFrequency > 255) {
        	sclFrequency >>= 2
        	prescaler++
    	}
    
    	+{TWSR}+ = (prescaler << +{TWPS0}+)
    	+{TWBR}+ = sclFrequency    
	    +{TWSR}+ = 0
    	+{TWBR}+ = 72
    	+{TWCR}+ = (1 << +{TWEN}+) | (1 << +{TWEA}+)
    }
	
	public enableAsSlave() {
	}
	
	---
	Read a single byte from the bus. If ack is true, an ack will be sent.
	---
	public uint8 get(bool ack) {
	    +{TWCR}+ = (1 << +{TWINT}+) | (1 << +{TWEN}+) | (ack ? (1 << +{TWEA}+) : 0)    
	    while(!ready()) {}

    	return +{TWDR}+		
	}
	
	---
	Write a single byte to the bus. Returns 0 if no error. 
	--- 
	public uint8 put(uint8 data) {
	    +{TWDR}+ = data    
    	+{TWCR}+ = (1 << +{TWINT}+) | (1 << +{TWEN}+) | (1 << +{TWEA}+)    
    	while(!ready()) {}
    
    	if((+{TWSR}+ & 0xF8) != MT_DATA_ACK) {
    		return 1
    	}
    
    	return 0
	}
	
	---
	Sends a start condition to the addressed client and true if writing to the bus.
	---
	public uint8 start(uint8 address, bool write) {
	    +{TWCR = (1 << TWINT) | (1 << TWSTA) | (1 << TWEN) | (1 << TWEA)}+    
    	while(!ready()) {}
    
    	if(((+{TWSR}+ & 0xF8) != START) && ((+{TWSR}+ & 0xF8) != RESTART)) {
        	#printf "TWSR (1): 0x%x\n", (TWSR & 0xF8)
        	return 1
    	}
    
    	+{TWDR}+ = (address << 1) | (write ? 0 : 1)
    
    	# changed from |= to =
    	+{TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWEA)}+    
    	while(!ready()) {}
    
    	if(((+{TWSR}+ & 0xF8) != MT_SLA_ACK) && ((+{TWSR}+ & 0xF8) != MR_SLA_ACK)) {
        	#printf "TWSR (2): 0x%x\n", (TWSR & 0xF8)
        	return 2
    	}
    
    	return 0
	}

	# send a stop condition on the bus
	public stop() {
	    +{TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWSTO) | (1 << TWEA)}+
	}
	
}====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/amaret/mcu.atmel.atmega328p/Interrupts.p
>>> test source:
package mcu.atmel.atmega328p

from mcu.atmel.atmega import InterruptMeta{"TIMER0_COMPA_vect", "TIMSK0", "OCIE0A", "TIFR0", "OCF0A"} as Timer0MatchA

composition Interrupts {

	export Timer0MatchA
	
}====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/amaret/mcu.atmel.atmega328p/Mcu.p
>>> test source:
---

Composition representing the configuration / layout of what's available from an ATMega328p

---

package mcu.atmel.atmega328p

import Atmega328p
import GlobalInterrupts
import Interrupts
#import I2C
import TimerMilli8BitTimer0
import Uart

import GpioMeta {"PORTB", "DDRB", 3} as PB3
import GpioMeta {"PORTB", "DDRB", 4} as PB4
import GpioMeta {"PORTB", "DDRB", 5} as PB5

#import GpioMeta {"PORTC", "DDRC", 4} as PC4
#import GpioMeta {"PORTC", "DDRC", 5} as PC5
#import GpioMeta {"PORTD", "DDRD", 0} as PD0
#import GpioMeta {"PORTD", "DDRD", 1} as PD1
#import GpioMeta {"PORTD", "DDRD", 2} as PD2
#import GpioMeta {"PORTD", "DDRD", 3} as PD3
#import GpioMeta {"PORTD", "DDRD", 4} as PD4
#import GpioMeta {"PORTD", "DDRD", 5} as PD5
#import GpioMeta {"PORTD", "DDRD", 6} as PD6
#import GpioMeta {"PORTD", "DDRD", 7} as PD7

composition Mcu {

	#=========================
	# Mcu Methods
	#=========================

	export Atmega328p.reset
	export Atmega328p.shutdown
	export Atmega328p.wait
	export Atmega328p.nop
	#export Atmega328p.getSystemFrequency	# These lines give an error: 
	#export Atmega328p.setSystemFrequency	# "ambiguous function: getSystemFrequency"

	public host uint32 getSystemFrequency() { return Atmega328p.getSystemFrequency() }
	public host setSystemFrequency(uint32 hz) { Atmega328p.setSystemFrequency(hz) }
	
	#=========================	
	# Mcu Modules
	#=========================
	export GlobalInterrupts
	#export I2C
	export Interrupts
	export TimerMilli8BitTimer0
	export Uart
	
	# Gpio Pins
    export PB3
    export PB4
    export PB5
	
}

====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/amaret/mcu.atmel.atmega328p/TimerMilli8BitTimer0.p
>>> test source:
package mcu.atmel.atmega328p

import Atmega328p

import Interrupts
from Interrupts import Timer0MatchA as Interrupt
from pollen.interfaces import Handler
from pollen.interfaces import TimerDriver

module TimerMilli8BitTimer0 implements TimerDriver {

	+{ #include <avr/io.h> }+

	host TimerMilli8BitTimer0() {
	    ticksPerMs = Atmega328p.getSystemFrequency() / (64 * 1000) 		# We need to round this! (math.round?)
	}

	TimerMilli8BitTimer0() {
		+{TCCR0A}+ = TIMER0_MODE_CTC	# Clear Timer on Compare Match Mode
	    +{TCCR0B}+ = TIMER0_STOP       	# Timer off
    	+{OCR0A}+ = ticksPerMs         	# Set to appropriate value to trigger every ms given prescale val    
	}

	#public host setHandler(Handler.handle h = null) {
	#	Interrupt.setHandler(h)
	#}

	public setHandler(Handler.handle h = null) {
		Interrupt.setHandler(h)
	}

	public start() {
	    +{TCNT0}+ = 0;                	# Set timer counter = 0
	    Interrupt.clear()
	    Interrupt.enable()
	    +{TCCR0B}+ = TIMER0_DIV64  # setup pre-scale value & start the timer     
	}

	public stop() {
	    Interrupt.disable()    # disable compare on match interrupt 
    	Interrupt.clear()      # clear any pending interrupts
	    +{TCCR0B}+ = TIMER0_STOP      # stop the timer    
	}

	public bool running() {
	    return +{TCCR0B}+ != 0 && Interrupt.enabled()
	}	
	
	#======================
	# Private members
	#======================
	host uint16 ticksPerMs = 0		# compute ticksPerMs in host initializer

    host uint8 TIMER0_MODE_CTC 	= 0x02  		# these should be const!
    host uint8 TIMER0_STOP 		= 0x00    
    host uint8 TIMER0_DIV1 		= 0x01    
    host uint8 TIMER0_DIV8 		= 0x02
    host uint8 TIMER0_DIV64 	= 0x03
    host uint8 TIMER0_DIV256 	= 0x04    
	
}====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/amaret/mcu.atmel.atmega328p/Uart.p
>>> test source:
package mcu.atmel.atmega328p

from pollen.interfaces import Uart as UartI

import Atmega328p as Mcu

module Uart implements UartI {

    +{ #include <avr/io.h> }+
    
    host Uart() {
		# Calculate initial values for default baud rate 
	    baudh = (((Mcu.getSystemFrequency() / (baudRate * 16)) - 1) >> 8)
	    baudl = (((Mcu.getSystemFrequency() / (baudRate * 16)) - 1))   
    }
    
    Uart() {

	    +{UBRR0H}+ = baudh
	    +{UBRR0L}+ = baudl
    	+{UCSR0B |= (1 << RXEN0) | (1 << TXEN0)}+    # Enable receiver and transmitter

    	# TODO: Set data, stop, parity bits from config params for now, 
    	# set 8 data bits, 1 stop bit, no parity
    	+{UCSR0C |= (1 << UCSZ00) | (1 << UCSZ01)}+  
    }
    
    public put(uint8 data) {
    	while (!(+{UCSR0A}+ & (1 << +{UDRE0}+))) { }
    	+{UDR0}+ = data
    }
    
    public uint8 get() {
	    while (!(+{UCSR0A}+ & (1 << +{RXC0}+))) { }  # Wait for data to be received
	    return +{UDR0}+                              # Get & return rcvd data from buffer    
    }
    
    public flush() {
	    volatile uint8 dummy = 0
	    while (+{UCSR0A}+ & (1 << +{RXC0}+)) { dummy = +{UDR0}+ }    
    }

    public setBaud(uint32 baud) {
		baudRate = baud
	    +{UBRR0H}+ = (((Mcu.getSystemFrequency() / (baudRate * 16)) - 1) >> 8)
	    +{UBRR0L}+ = (((Mcu.getSystemFrequency() / (baudRate * 16)) - 1))    
    }
    
    public host setBaud(uint32 baud) {
		baudRate = baud
	    baudh = (((Mcu.getSystemFrequency() / (baudRate * 16)) - 1) >> 8)
	    baudl = (((Mcu.getSystemFrequency() / (baudRate * 16)) - 1)) 
    }
    
   	uint32 baudRate = 9600
	host uint8 dataBits = 8
	host uint8 stopBits = 1
	host uint8 parity = 0
	
	host uint8 baudh
	host uint8 baudl
}
====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/amaret/mcu.atmel.atmega328p/Wait.p
>>> test source:
---

A microsecond busywait delay module

---
package mcu.atmel.atmega328p

from pollen.interfaces import Wait as WaitI

module Wait implements WaitI {

    # host initializer for this module computes a string with the set of
    # nop operations necessary to delay for 1us given the MCU's frequency
    host Wait() {

    }

	public us(uint32 microseconds) {

	    # one loop takes 4-5 cpu cycles
	    # THIS LOOP SHOULD BE GENERATED, GIVEN MCU FREQ,
	    # GENERATE ENOUGH nops SUCH THAT N*NOPS + 4 = (mcuFreq / 1000000)

		for (uint32 i = 0; i < microseconds; i++) {
	        +{ asm("nop") }+
	        +{ asm("nop") }+
	        +{ asm("nop") }+
	        +{ asm("nop") }+
	        +{ asm("nop") }+
	        +{ asm("nop") }+
	        +{ asm("nop") }+
	        +{ asm("nop") }+
	        +{ asm("nop") }+
	        +{ asm("nop") }+
	        +{ asm("nop") }+
		}
	}
}====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/amaret/mcu.localhost/GlobalInterrupts.p
>>> test source:
package mcu.localhost

---

Global Interrupts module for your desktop host.

---

from pollen.interfaces import GlobalInterrupts as GI

module GlobalInterrupts implements GI {

	public bool disable() {
		return false
	}
    
    public enable() {

    }
    
    public restore( bool state ) {

    }
}====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/amaret/mcu.localhost/Mcu.p
>>> test source:
package mcu.localhost

from pollen.interfaces import Mcu as McuI

module Mcu implements McuI {
	
	public reset() {
	}
	
	public shutdown() {
	
	}
}====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/amaret/mcu.localhost/Wait.p
>>> test source:
package mcu.localhost

from pollen.interfaces import Wait as WaitI

module Wait implements WaitI {

	+{ #include <unistd.h> }+

	public us( uint32 microseconds ) {
		+{ usleep(microseconds) }+
	}
}====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/amaret/mcu.localhost/Write.p
>>> test source:
package mcu.localhost

---
This module simply encapsulates a way to print output on the localhost
---

module Write {

	+{ #include <stdio.h> }+

	public outs(string s) {
		+{printf("%s", s)}+
	}

	public outi(uint32 i) {
		+{printf("%i", i)}+
	}
}====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/amaret/mcu.ti.msp430/GlobalInterrupts.p
>>> test source:
---
Global Interrupts module for msp430

---
package mcu.ti.msp430

from pollen.interfaces import GlobalInterrupts as GI

module GlobalInterrupts implements GI {

	# This will be replaced with a more intelligent approach
 	+{ #include <msp430g2231.h> }+
 	+{ #include <legacymsp430.h> }+

	public bool disable() {
		uint16 x = 0
		# This is specific to msp430-gcc		
		+{x}+ = +{ __read_status_register() }+
		+{dint()}+
		return (x & +{GIE}+) != 0 ? true : false
	}
    
    public enable() {
		+{eint()}+
    }
    
    public restore( bool state ) {
		if (state == true) {		# GIE was enabled
			enable()
		}
    }

}====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/amaret/mcu.ti.msp430/GpioMeta.p
>>> test source:
package mcu.ti.msp430
 
meta {string part, string dirr, string inr, string outr, uint8 pin}
from pollen.interfaces import Gpio
module GpioMeta implements Gpio {

	# when host members are available do this:
	# host string inc = part + ".h"
	# +{ #include <inc>}+

	+{ #include <msp430g2231.h> }+

	public set() {
		+{outr}+ |= (1 << pin)
	}

	public clear() {
		+{outr}+ &= ~(1 << pin)
	}
	
	public toggle()	{
		+{outr}+ ^= (1 << pin)
	}
	
	public bool get() {
		return +{inr}+ & (1 << pin) ? true : false
	}
	
	public makeInput() {
		+{dirr}+ &= ~(1 << pin)
	}
	
	public bool isInput() {
		return +{dirr}+ & (1 << pin) ? false : true
	}
	
	public makeOutput()	{
		+{dirr}+ |= (1 << pin)
	}
	
	public bool isOutput() {
		return +{dirr}+ & (1 << pin) ? true : false
	}

}
 ====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/amaret/mcu.ti.msp430/I2CUsi.p
>>> test source:
from pollen.interfaces import I2C

module I2CUsi implements I2C {

	#enum ClockSource {SCLK, ACLK, SMCLK, USISWCLK, TACCR0, TACCR1}
	
	# some of these should be host variables
	uint32 slowestSlaveFrequency = 100000
	uint32 mcuFreq = 1000000

	#uint8 clockSource = ClockSource.SMCLK
	uint8 divisor
	uint8 source

	I2CUsi() {
		uint32 SCLFreq
		SCLFreq = 0
		
	    +{P1OUT}+ = 0xC0		# Use P1.6 & P1.7 Pullups, others to 0
	    +{P1REN}+ |= 0xC0		# Enable P1.6 & P1.7 Pullups
	    +{P1DIR}+ = 0xFF
	    # +{P1SEL}+ = 0xC0
	
	    # Configure the clock source
        source = +{USISSEL_2}+	# SMCLK	    
        
	    ---
	    if(clockSource == SCLK) {
	        source = ^USISSEL_0
	    }
	    if(clockSource == ACLK) {
	        source = ^USISSEL_1
	    }
	    if(clockSource == SMCLK) {
	        source = ^USISSEL_2
	    }
	    if(clockSource == USISWCLK) {
	        source = ^USISSEL_4
	    }
	    if(clockSource == TACCR0) {
	        source = ^USISSEL_5
	    }
	    if(clockSource == TACCR1) {
	        source = ^USISSEL_6
	    }
   	    ---
	    # Find necessary SCL frequency for stable communication
	    # with all attached slaves
	    SCLFreq = mcuFreq # >> 4
	    divisor = 0
	    while(SCLFreq > slowestSlaveFrequency) {
	        SCLFreq >>= 1
	        divisor++
	    }
	    divisor <<= 5
	}

	public enableAsMaster() {
		+{ADC10AE0}+ = 0
    	#ADC10AE1 = 0

    	+{USICTL0    = USIPE7 | USIPE6 | USIMST | USISWRST}+  # ~USILSB
 	    +{USICTL1    = USII2C}+     # ~USICKPH
    	+{USICKCTL}+ = divisor | source | +{USICKPL}+
	    +{USICNT}+   = 0 	#USISCLREL  # ~USI16B
	    +{USICTL0   &= ~USISWRST}+
	    +{USICTL1   &= ~USIIFG}+
	}
	
	public enableAsSlave() {
	
	}
	
	---	
	Read a single byte from the bus. If ack is true, an ack will be sent. 
	Returns byte read.
	---
	public uint8 get(bool ack) {
		uint8 data

	    +{USICTL0 &= ~USIOE}+ 					# Disable output
            
    	+{USICNT = (USICNT & 0xE0) | 0x08}+ 	# Set the bit count
    
    	while(!ready()) {}	    				# Wait for all bits to be read        
    	data = +{USISRL}+						# Read the data
    	# Load the shift register with 0 for ACK or 1 for NACK (active LOW) 
    	+{USISRL}+ = ack ? 0x00 : 0x80    
	    +{USICTL0 |= USIOE}+					# Enable output
    	+{USICNT = (USICNT & 0xE0) | 0x01}+		# Set the bit count
    
    	while(!ready()) {}						# Wait for the bit to be transmitted
        
    	return data								# Return the read data	
	}
	
	---
	Write a single byte to the bus. Returns true if acked. 
	---
	public bool put(uint8 data) {	
	    +{USISRL}+ = data		    			# Write data into the shift register    
    	+{USICTL0 |= USIOE}+					# Enable output
    	+{USICNT = (USICNT & 0xE0) | 0x08}+     # Set the bit count
    	while(!ready()) {}		    		# Wait for all bits to be written    
    	+{USICTL0 &= ~USIOE}+					# Disable output
    	+{USICNT = (USICNT & 0xE0) | 0x01}+		# Load the counter with 1 to read the ack
    	while(!ready()){}
    
    	# Return the ACK if there is one
	    #return USISRL == 0x80 ? true : false
    	return (+{USISRL}+ & 0x01) ? true : false
	}
	
	---
	Sends a start condition to the addressed client and specify if writing or reading.
	---
	public bool start(uint8 address, bool write) {
	    +{USISRL}+ = 0					# Set the MSB of the shift register to 0    
    	+{USICTL0 |= USIOE | USIGE}+	# Latch/SDA output enabled
    	+{USICTL0 &= ~USIGE}+       	# Latch disabled	# added a ~
    
    	# Write address and read/write bit
    	# Return whether start was ACK'd or not
    	return put((address << 1) | (write ? 0 : 1))
	}

	---
	Send a stop condition on the bus
	---
	public stop() {
	    +{USICTL0 |= USIOE}+		   			# Enable output
    	+{USISRL}+ = 0	    					# Set the MSB of the shift register to 0    
    	+{USICNT = (USICNT & 0xE0) | 0x01}+     # Read one bit
    	while(!ready()) {}		    		# Wait until we have read the bit
    	+{USISRL}+ = 0xFF						# Set the register all high
       	+{USICTL0 |= USIGE}+					# Set low-to-high transition
    
    	# Resume normal latching, disable output
    	+{USICTL0 &= ~USIOE & ~USIGE}+
	}
	
	bool ready() {
		# Check the USIIFG interrupt flag. This is automatically set whenever
    	# the USICNTx is 0, and automatically cleared whenever USICNTx != 0
   	    return +{(USICTL1 & USIIFG)}+ ? true : false
	}
}====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/amaret/mcu.ti.msp430/InterruptMeta.p
>>> test source:
---

Interrupt meta module for MSP microcontrollers using GCC compiler

---

from pollen.interfaces import Handler
from pollen.interfaces import Interrupt

meta {string part, string vector, string enableRegister, string enableBit, string clearRegister, string clearBit}

module InterruptMeta implements Interrupt {

	# This is all msp430 gcc specific!
	+{ #include <msp430g2231.h> }+
	+{ #include <legacymsp430.h> }+
	
	host string v2 = vector + "_ISR() {"
	
	+{ interrupt (}+
	+{vector}+
	+{) }+
	+{vector + "_ISR() {"}+	
   	+{ isr() }+
    +{;} }+ 

	public host setHandler(Handler.handle h) { @h = h }
	
	public setHandler(Handler.handle h) { @h = h }

	public enable() {
		+{enableRegister}+ |= (1 << +{enableBit}+)
	}

	public bool enabled() {
		return +{enableRegister}+ & (1 << +{enableBit}+)
	}

	public disable() {
		+{enableRegister}+ &= ~(1 << +{enableBit}+)
	}

	public clear() {
		+{clearRegister}+ &= ~(1 << +{clearBit}+)
	}
	
	#====================
	# Private members
	#====================
	Handler.handle h = 0
	
	isr() {
		if (h != null) { h() }
	}
}
====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/amaret/mcu.ti.msp430/Msp430.p
>>> test source:
from pollen.interfaces import Mcu

interface Msp430 extends Mcu {

    host uint32 getMasterClock()
    host uint32 getSubMasterClock()    
    host uint32 getAuxiliaryClock()
    
    host setMasterClock(uint32 freq)    
    host setSubMasterClock(uint32 freq)
    host setAuxiliaryClock(uint32 freq)

}====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/amaret/mcu.ti.msp430/TimerA0Interrupt.p
>>> test source:
package mcu.ti.msp430

from pollen.interfaces import Interrupt
from pollen.interfaces import Handler

module TimerA0Interrupt implements Interrupt {

	Handler.handle h
	
	# This is all msp430 gcc specific!
	+{ #include <msp430g2231.h> }+
	+{ #include <legacymsp430.h> }+

	+{ interrupt (TIMERA0_VECTOR) TimerA0Interrupt_ISR() { }+
    	+{isr()}+
    +{;} }+ 

	public host setHandler(Handler.handle h) { @h = h }
	
	public setHandler(Handler.handle h) { @h = h }
	
	public enable() {
		+{TACCTL0}+ |= (1 << 4)
	}

	public bool enabled() {
		return +{TACCTL0}+ & (1 << 4) ? true : false
	}

	public disable() {
		+{TACCTL0}+ &= ~(1 << 4)	
	}

	public clear() {
		+{TACCTL0}+ &= ~(1 << 0)
	}
	
	isr() {
		if (h != null) { h() }
	}
}====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/amaret/mcu.ti.msp430/TimerMilliA0.p
>>> test source:
package mcu.ti.msp430

---

This module implements a millisecond timer using hardware timer A0.

---

from pollen.interfaces import TimerDriver
from pollen.interfaces import Handler
import TimerA0Interrupt as Interrupt

module TimerMilliA0 implements TimerDriver {

	+{ #include <msp430g2231.h> }+

	host uint16 ticksPerMs = 1000	# compute ticksPerMs in host initializer

	TimerMilliA0() {
		+{TACTL = TASSEL_2 + MC_0}+  # Timer using SMCLK, set to off      
	    +{TACCR0}+ = ticksPerMs      # Count to 10K, @1MHZ thats 1ms.
	}

	#public host setHandler(Handler.handle h = null) {
	#	Interrupt.setHandler(h)
	#}

	public setHandler(Handler.handle h = null) {
		Interrupt.setHandler(h)
	}

	public start() {
		+{TAR}+ = 0
		Interrupt.clear()
		Interrupt.enable()
		+{TACTL |= MC_1}+         	 # Timer on in Up Mode
	}

	public stop() {
	    Interrupt.disable()
    	Interrupt.clear()
		uint16 mask = ~(3 << 4) +{;}+
	    +{TACTL}+ &= mask    
	}

	public bool running() {
	    return (+{TACTL & MC_1}+ && Interrupt.enabled()) ? true : false
	}
}====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/amaret/mcu.ti.msp430/TimerMilli.p
>>> test source:
package mcu.ti.msp430

from pollen.interfaces import Timer as TimerI
from pollen.events import Events
from pollen.events import Event{uint8} as Event
import TimerMilliA0 as TA0

module TimerMilli implements TimerI {

	Event event
	uint16 duration
	uint16 current
	bool repeat
	
	# host TimerMilli() {} 	# can't call host functions from there yet

	TimerMilli() {
		TA0.setHandler(timerInterrupt)
	}
	
    public start(Event onTick, uint16 duration, bool repeat = true) {
    	@event = onTick; 
    	@duration = duration; 
    	@repeat = repeat; 
    	@current = 0    	
    	TA0.start()
    }
    
    public stop() {
		TA0.stop()    
    }

	public bool periodic() { return repeat }

    public bool running() { return TA0.running() }

    public uint16 ticksPerSecond() { return 1000 }
    
    timerInterrupt() {
		if (++current == duration) {			
	    	if (repeat == true) {
	    		current = 0
	    	} else {
	    		TA0.stop()
	    	}
	    	
	    	if (event != 0) {
	    		Events.postFromInterrupt(event)
    		}    	
		}

    }
}====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/amaret/mcu.ti.msp430/Wait.p
>>> test source:
---

A microsecond busywait delay module

---
package mcu.ti.msp430

from pollen.interfaces import Wait as WaitI

module Wait implements WaitI {

    # host initializer for this module should compute a string with the set of
    # nop operations necessary to delay for 1us given the MCU's frequency
    # host Wait() {}

	public us(uint32 microseconds) {
		volatile uint32 t

	    # once upon a time it was measured that for more than one 
    	# iteration of the loop it takes about 7 cycles per iteration.  		
		for (uint32 i = 0; i < (microseconds / 10) + 1; i++) {
			t = 0
		}
	}
}====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/amaret/mcu.ti.msp430g2231/Interrupts.p
>>> test source:
package mcu.ti.msp430g2231

from mcu.ti.msp430 import InterruptMeta{} as GpioP1
from mcu.ti.msp430 import InterruptMeta{} as GpioP2

composition Interrupts {

	export GpioP1
	export GpioP2
	
}====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/amaret/mcu.ti.msp430g2231/Mcu.p
>>> test source:
package mcu.ti.msp430g2231

import Msp430g2231
from mcu.ti.msp430 import GlobalInterrupts
from mcu.ti.msp430 import TimerMilliA0

from mcu.ti.msp430 import GpioMeta{"msp430g2231.h", "P1DIR", "P1IN", "P1OUT", 0} as P1_0
#from mcu.ti.msp430 import GpioMeta{"msp430g2231.h", "P1DIR", "P1IN", "P1OUT", 1} as P1_1
#from mcu.ti.msp430 import GpioMeta{"msp430g2231.h", "P1DIR", "P1IN", "P1OUT", 2} as P1_2
#from mcu.ti.msp430 import GpioMeta{"msp430g2231.h", "P1DIR", "P1IN", "P1OUT", 3} as P1_3
#from mcu.ti.msp430 import GpioMeta{"msp430g2231.h", "P1DIR", "P1IN", "P1OUT", 4} as P1_4
#from mcu.ti.msp430 import GpioMeta{"msp430g2231.h", "P1DIR", "P1IN", "P1OUT", 5} as P1_5
from mcu.ti.msp430 import GpioMeta{"msp430g2231.h", "P1DIR", "P1IN", "P1OUT", 6} as P1_6
#from mcu.ti.msp430 import GpioMeta{"msp430g2231.h", "P1DIR", "P1IN", "P1OUT", 7} as P1_7


composition Mcu { 	# implements pollen.interfaces.Mcu

	#=========================
	# Mcu Methods
	#=========================

	export Msp430g2231.reset
	export Msp430g2231.shutdown
	export Msp430g2231.wait
	export Msp430g2231.nop

	#=========================	
	# Mcu Modules
	#=========================
		
	export GlobalInterrupts
	export TimerMilliA0

	# Gpio Port P1
	export P1_0
	#export P1_1
	#export P1_2
	#export P1_3
	#export P1_4
	#export P1_5
	export P1_6
	#export P1_7
}====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/amaret/mcu.ti.msp430g2231/Msp430g2231.p
>>> test source:
---
This module provides an msp430g2231 specific implementation of the Mcu interface.

The MCLK and SMCLK are configured here. Possible combinations are:
MCLK: 1MHz,    SMCLK: 1MHz,    500KHz,     250KHz,     125KHz
MCLK: 500KHz,  SMCLK: 500KHz,  250KHz,     125KHz,     62.5KHz
MCLK: 250KHz,  SMCLK: 250KHz,  125KHz,     62.5KHz,    31.25KHz
MCLK: 125KHz,  SMCLK: 125KHz,  62.5KHz,    31.25KHz,   15.625KHz

---

package mcu.ti.msp430g2231

from pollen.interfaces import Mcu as McuI
#from mcu.ti.msp430 import Msp430
from mcu.ti.msp430 import Wait

module Msp430g2231 implements McuI {	# implements Msp430 (when interface inheritance works)

	host uint32 mclkFrequency = 1000000
	host uint32 smclkFrequency = 1000000
	host uint32 aclkFrequency = 0

	+{ #include <msp430g2231.h> }+

	---
	This function needs a revamp! Leverage the host to figure shit out.
	---
	public reset() {

	    +{WDTCTL = WDTPW | WDTHOLD}+         		# Stop watchdog timer
	    +{BCSCTL1 = CALBC1_1MHZ}+					# Set MCLK to calibrated 1MHZ
	    +{DCOCTL = CALDCO_1MHZ}+
	    
    	if (mclkFrequency == 1000000) {      		
		    #+{DCOCTL}+ = 0
        
	        if(smclkFrequency == 500000) {	 		# Set SMCLK to 1/2 MCLK
	            +{BCSCTL2 = DIVS_1}+
	        } elif (smclkFrequency == 250000) { 	# Set SMCLK to 1/4 MCLK
	            +{BCSCTL2 = DIVS_2}+
	        } elif (smclkFrequency == 125000) { 	# Set SMCLK to 1/8 MCLK
	            +{BCSCTL2 = DIVS_3}+
	        }
	    } elif (mclkFrequency == 500000) {
	        +{BCSCTL2 = DIVM_1}+			 	  # Set divider for 1/2 MCLK
        
        	if(smclkFrequency == 250000) {	 	  # Set SMCLK to 1/2 MCLK
	            +{BCSCTL2 = DIVS_1}+
    	    } elif (smclkFrequency == 125000) {   # Set SMCLK to 1/4 MCLK
	            +{BCSCTL2 = DIVS_2}+
	        } elif (smclkFrequency == 62500) {    # Set SMCLK to 1/8 MCLK
	            +{BCSCTL2 = DIVS_3}+
	        }
    	} elif (mclkFrequency == 250000) { 
        	+{BCSCTL2 = DIVM_2}+			 	  # Set divider for 1/4 MCLK
        
        	if (smclkFrequency == 125000) { 	  # Set SMCLK to 1/2 MCLK
            	+{BCSCTL2 = DIVS_1}+
        	} elif (smclkFrequency == 62500) {    # Set SMCLK to 1/4 MCLK
            	+{BCSCTL2 = DIVS_2}+
        	} elif (smclkFrequency == 31250) {    # Set SMCLK to 1/8 MCLK
            	+{BCSCTL2 = DIVS_3}+
        	}
    	} elif (mclkFrequency == 125000) {
            +{BCSCTL2 = DIVM_3}+			  # Set divider for 1/8 MCLK
                	        
	    	if (smclkFrequency == 62500) {        # Set SMCLK to 1/2 MCLK
            	+{BCSCTL2 = DIVS_1}+
        	} elif(smclkFrequency == 31250) {     # Set SMCLK to 1/4 MCLK
 	           	+{BCSCTL2 = DIVS_2}+
        	} elif(smclkFrequency == 15625) {     # Set SMCLK to 1/8 MCLK
            	+{BCSCTL2 = DIVS_3}+
        	}
    	} else {
    		# Notify of wrong configuration settings
    	}
    	
    	# +{BCSCTL1 &= ~(XTS)}+         # set XTS bit to low frequency mode
	    # +{BCSCTL2}+ |= 0x5            # divide the SM clock by 8
    	# +{BCSCTL3 |= LFXT1S_0}+       # set ACLK to 32768Hz crystal
	}

	public shutdown() {
	}
	
	public wait(uint32 us) {
		Wait.us(us)
	}
	
	public nop() {
        +{ asm("nop") }+		
	}
}====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/amaret/mcu.ti.msp430g2231/SoftwareUart.p
>>> test source:
from pollen.interfaces import TimerDriver
from pollen.interfaces import Uart
from pollen.interfaces import Gpio

module SoftwareUart implements Uart {

	host TimerDriver Timer = 0
	host Gpio RxPin = 0
	host Gpio TxPin = 0

   	uint32 baudRate = 9600
	host uint8 dataBits = 8
	host uint8 stopBits = 1
	host uint8 parity = 0	
	host uint8 baudh
	host uint8 baudl
    
    SoftwareUart() {
    
    }
    
    host bindInterfaces (TimerDriver TD, Gpio Rx, Gpio, Tx) {
    	Timer = TD
    	RxPin = Rx
    	TxPin = Tx
    }
    
    public put( uint8 data ) {
    
    }
    
    public uint8 get() {
    
    }
    
    public flush() {
    }

    public setBaud( uint32 baud ) {
    
    }
}====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/amaret/ti.launchpad/LaunchPad.p
>>> test source:
package board.ti

from mcu.ti.msp430g2231 import Mcu
from Mcu import P1_0

from pollen.parts import Led{false} as Led

composition LaunchPad {

	export Mcu
    export Led
    
    export P1_0
    
    host LaunchPad() {
        Led.bindPin(P1_0)
	}

}====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/base/pollen.data/Queue.p
>>> test source:
package pollen.data 

---

FIFO queue data type implemented as an array of fixed length.

---
#from mcu.localhost import Write

meta {type T, uint8 cap} type Queue {
	
	host uint8 capacity = cap
	T elements[capacity]
	uint8 head = 0, tail = 0, num = 0
		
	Queue() {
		@head = @tail = @num = 0
	}
	
	public host setCapacity(uint8 cap) { @capacity = cap }

	public bool enqueue(T t) {
		if (num < capacity) {
			elements[tail] = t
			num++
			tail++
			if (tail == capacity) {	
				tail = 0		# wrap around
			}
			
        	#Write.outs("enqueue: h, t: ")
        	#Write.outi(head)
        	#Write.outs(" ")
        	#Write.outi(tail)
        	#Write.outs("\n")
        				
			return true
		} else {
			return false
		}
	}
	
	public T dequeue() {
		T t = 0
				
		if (num > 0) {
			t = elements[head]
			head++ 
			if (head == capacity) { head = 0 } 
			num-- 
        	#Write.outs("dequeue: h, t: ")
        	#Write.outi(head)
        	#Write.outs(" ")
        	#Write.outi(tail)
        	#Write.outs("\n")
		}
		
		return t
	}
	
	public uint8 length() {
		return num
	}
	
	public uint8 getCapacity() {
		return capacity
	}
	
	public host uint8 getCapacity() {
		return capacity
	}
}====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/base/pollen.events/Dispatcher.p
>>> test source:
package pollen.events

---

Event Dispatcher 

---

import Event{any} as AE

from pollen.interfaces import GlobalInterrupts
from pollen.data import Queue{AE, 10} as AEQueue

module Dispatcher {

    public host bindGlobalInterrupts(GlobalInterrupts gi) {
        GI = gi
    }

	public post(AE e) { 
		bool on = GI.disable()
		events.enqueue(e)
		GI.restore(on) 
	}
	
	public postFromInterrupt(AE e) { events.enqueue(e) }

  	public run() {
        GI.enable() 		# start loop with interrupts enabled
				
		while(true) {

			# Interm dispatcher loop until the one below is installed.
			bool on = GI.disable() 		# disable interrupts
	        AE e = events.dequeue()	
			GI.restore(on) 				# re-enable interrupts
	
			if (e != null) {				
				e.handle()				# handle event
			}			
			--- Should Add This Part Soon!
             else {
			  	pollen.hibernate()		# sleep processor
			}
			---
		}
	}
	
	
	#==================================
	# Private Members
	#==================================
    host GlobalInterrupts GI               # interface representative
	value{AEQueue} events                  # should be: AEQueue events()

}====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/base/pollen.events/EventHandler.p
>>> test source:
package pollen.events

---

EventHandler meta interface

---

meta{type T} interface EventHandler {
	public handle(T e)
}====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/base/pollen.events/Event.p
>>> test source:
package pollen.events

---

Event

---

import EventHandler{any} as EH

meta{type T = uint8} type Event {

  uint8 priority = 0
  EH.handle handler = 0
  T data = 0

  public Event(EH.handle handler = 0, T data = 0, uint8 priority = 0) {
     @handler = handler; @data = data; @priority = priority
  }

  public uint8 getPriority() { return priority }
  public setPriority(uint8 priority) { @priority = priority }

  public EH.handle getHandler() { return @handler }
  public setHandler(EH.handle handler) { @handler = handler }

  public T getData() { return data }
  public setData(T data) { @data = data }

  public handle() {
  	if (handler != null) {	  	
     	handler(@)
     }
  }

}====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/base/pollen.events/Events.p
>>> test source:
package pollen.events

from pollen.interfaces import GlobalInterrupts
import Dispatcher

composition Events {

    public host bindGlobalInterrupts(GlobalInterrupts gi) {
        Dispatcher.bindGlobalInterrupts(gi)
    }

    export Dispatcher.post                  # Post event
    export Dispatcher.postFromInterrupt     # Post event from interrupt context
    export Dispatcher.run                   # Run event system

}====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/base/pollen.interfaces/GlobalInterrupts.p
>>> test source:
package pollen.interfaces

---
Global Interrupts interface
---

interface GlobalInterrupts {

    
    # Disable global interrupts returning their present state,
    # 	true = enabled, false = disabled
    
    bool disable()
    
    
    # Enable global interrupts.

    enable()
    

	# Restore global interrupts to the given state (true = on, false = off)
	
    restore( bool state )
    
}
====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/base/pollen.interfaces/Gpio.p
>>> test source:
package pollen.interfaces

---

---

interface Gpio {

	set()				# Set the pin high

	clear()				# Set the pin low
	
	toggle()			# Toggle the state of the pin
	
	bool get()			# Get the pin state
	
	makeInput()			# Make pin an input
	
	bool isInput()		# Check if pin is configured as an input
	
	makeOutput()		# Make pin an output
	
	bool isOutput()		# Check if pin is configured as an output
	
}====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/base/pollen.interfaces/Handler.p
>>> test source:
package pollen.interfaces

---

Definition of a simple void handler interface for use with method references

---

interface Handler {

	handle()
	
}

====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/base/pollen.interfaces/I2C.p
>>> test source:
package pollen.interfaces

---
Standard Inter-Integrated Circuit (I2C) Serial Bus Driver Interface
---

interface I2C {

	enableAsMaster()
	
	enableAsSlave()
	
	# read a single byte from the bus. If ack is true, an ack will be sent. 
	# returns byte read.
	uint8 get( bool ack )
	
	# write a single byte to the bus. Returns error codes: 0, no error. 
	# 1, error while transmitting 
	uint8 put( uint8 data )
	
	# sends a start condition, an address of a client and true if writing to or 
	# false if reading from a client on the bus.
	uint8 start( uint8 address, bool write )

	# send a stop condition on the bus
	stop()
	
}====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/base/pollen.interfaces/Interrupt.p
>>> test source:
package pollen.interfaces

---

Standard interrupt interface.

---


import Handler

interface Interrupt {
	
	#host setHandler(Handler.handle h)	
	
	public setHandler(Handler.handle h)

	public enable()

	public bool enabled()

	public disable()

	public clear()

}====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/base/pollen.interfaces/Led.p
>>> test source:
package pollen.interfaces

interface Led {

	on()			# Turn Led On
	
	off()			# Turn Led Off
	
	toggle()		# Toggle Led State
	
	bool isOn()		# Check if Led is On
}

====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/base/pollen.interfaces/Mcu.p
>>> test source:
package pollen.interfaces

---

---

interface Mcu {

    reset()			# Called on power up and reset 
    
    shutdown()		# Called on shutdown
    
    wait(uint32 us)	# Microsecond delay
    
    nop()			# Single cycle delay
    
	#host uint32 getSystemFrequency()
	
	uint32 getSystemFrequency()
	
	#host setSystemFrequency(uint32 hz)
	
	setSystemFrequency(uint32 hz)
	
}
====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/base/pollen.interfaces/TimerDriver.p
>>> test source:
package pollen.interfaces

import Handler

interface TimerDriver {

	setHandler(Handler.handle h = null)

	# host setHandler(Handler.handle h = null)
		
	start()

    stop()
	    
    bool running()
    
}====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/base/pollen.interfaces/Timer.p
>>> test source:
package pollen.interfaces

---

---

from pollen.events import Event{any} as Event

interface Timer {

	bool repeats()
    bool running()
    uint16 ticksPerSecond()

    start(Event onTick, uint16 duration, bool repeat = true)
    stop() 
}====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/base/pollen.interfaces/Uart.p
>>> test source:
package pollen.interfaces


interface Uart {

	#host config(uint32 baudRate, uint8 dataBits, uint8 stopBits, uint8 parity)
    
    put( uint8 data )
    
    uint8 get()
    
    flush()

    setBaud( uint32 baud )

}
====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/base/pollen.interfaces/Wait.p
>>> test source:
package pollen.interfaces

---
Microsecond busy wait interface
---

interface Wait {

	us(uint32 dt)

}====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/base/pollen.parts
>>> test source:
====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/base/pollen.parts/Led.p
>>> test source:

from pollen.interfaces import Gpio

meta {bool isActiveLow = true}

module Led {

    host Gpio LedPin
    
    Led() {
        LedPin.clear()
        LedPin.makeOutput()
    }
    
    public host bindPin(Gpio p) {
        LedPin = p
    }
    
    public toggle() { LedPin.toggle() }
    
    public on() { 
        provided (isActiveLow == false) {
            LedPin.set() 
        } else {
            LedPin.clear()
        }
    }

    public off() { 
        provided (isActiveLow == false) {
            LedPin.clear()
        } else {
            LedPin.set()
        }
    }
    
    public bool isOn() { 
        provided (isActiveLow == false) {
            return LedPin.get() == false
        } else {
            return LedPin.get() == true
        }
    }

}====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/base/pollen.probe
>>> test source:
====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/base/pollen.probe/CycleCounter.p
>>> test source:
---

This module should provide a generic cycle counter using a raw hardware timer

---====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/base/pollen.probe/Measure.p
>>> test source:
---

This module wraps the cycle counter and provides a simple interface to measure 
(with printed messages) cpu cycles.

---====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/base/pollen.time/Time.p
>>> test source:
package pollen.time

from pollen.interfaces import GlobalInterrupts
from pollen.interfaces import TimerDriver

import TimerMilli

composition Time {

	export TimerMilli

	public host bindGlobalInterrupts(GlobalInterrupts gi) {
	}
	
	public host bindTimerDriver(TimerDriver t) {
		TimerMilli.bindTimerDriver(t)
	}
}====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/base/pollen.time/TimerManager_.p
>>> test source:

from pollen.interfaces import Timer as TimerI
from pollen.interfaces import TimerDriver
from pollen.interfaces import GlobalInterrupts
from pollen.events import Events
from pollen.events import Event{uint8} as Event

module TimerManager {

	type Timer implements TimerI {

		public host init() { 
			id = numTimers
			numTimers++
			repeat = false
			print "\nTIMER INIT"
		}
		
		public bool repeats() { return repeat }

	    public bool running() { return timers[id] != 0 }

    	public uint16 ticksPerSecond() { return 1000 }

    	public start(Event e, uint16 d, bool r = true) {
			bool state = gint.disable()
			if (!running()) {
				expired = e
	    		duration = d
	    		elapsed = 0
	    		repeat = r
	    		timers[id] = @
	    	}
	   		gint.restore(state)
    
    		if (!hw_timer.running()) {
    			hw_timer.start()
    		}
    	}
    	
    	public stop() {
			bool state = gint.disable()
			timers[id] = null
    		gint.restore(state)
    	}

		#======================
		# Private members
		#======================
		host uint8 id
		Event expired
		uint32 duration
		uint32 elapsed
		bool repeat	
	}
	
	public host bindGlobalInterrupts(GlobalInterrupts gi) { 
		gint = gi 
	}
	
	public host bindTimerDriver(TimerDriver t) { 
		hw_timer = t 
	}

	#======================
	# Private members
	#======================	
	host GlobalInterrupts gint
	host TimerDriver hw_timer
	host uint8 numTimers = 0
	Timer timers[numTimers]

	timerISR() {		
		bool off = true

		for (uint8 i = 0; i < numTimers; i++) {
			if (timers[i] != 0) {
				timers[i].elapsed++
				
				if (timers[i].elapsed == timers[i].duration) {
					if (timers[i].expired != 0) {
						Events.postFromInterrupt(timers[i].expired)
						if (timers[i].repeat) {
							timers[i].elapsed = 0
						} else {
							timers[i].stop()
						}					
					} else {
						timers[i].stop()
					}					
				}
				off = false
			}
		}
		
		# all timers are off, turn hardware timer off
		if (off) {
			hw_timer.stop()
		}
	}
}====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/base/pollen.time/TimerManager.p
>>> test source:

from pollen.interfaces import Timer as TimerI
from pollen.interfaces import TimerDriver
from pollen.interfaces import GlobalInterrupts
from pollen.events import Events
from pollen.events import Event{uint8} as Event

module TimerManager {
	
	public host bindTimerDriver(TimerDriver t) { 
		hw_timer = t 
	}

	public host registerTimer

	#======================
	# Private members
	#======================	
	host GlobalInterrupts gint
	host TimerDriver hw_timer
	host uint8 numTimers = 0
	Timer timers[numTimers]

	timerISR() {		
		bool off = true

		for (uint8 i = 0; i < numTimers; i++) {
			if (timers[i] != 0) {
				timers[i].elapsed++
				
				if (timers[i].elapsed == timers[i].duration) {
					if (timers[i].expired != 0) {
						Events.postFromInterrupt(timers[i].expired)
						if (timers[i].repeat) {
							timers[i].elapsed = 0
						} else {
							timers[i].stop()
						}					
					} else {
						timers[i].stop()
					}					
				}
				off = false
			}
		}
		
		# all timers are off, turn hardware timer off
		if (off) {
			hw_timer.stop()
		}
	}
}====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/base/pollen.time/TimerMilliInterface.p
>>> test source:
package pollen.time

from pollen.interfaces import Handler

interface TimerMilli {

    start()
    stop()
    bool running()
    
    #host setHandlerH(Handler.handle h)
    setHandlerH(Handler.handle h)
}
====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/base/pollen.time/TimerMilli.p
>>> test source:
package pollen.time

from pollen.interfaces import Handler
from pollen.interfaces import TimerDriver

module TimerMilli {

	host TimerDriver timer
	uint16 count = 0
	uint16 duration = 0
	bool repeat = true
	Handler.handle clientTick

	TimerMilli() {
		timer.setHandler(timerTick)		
	}

	public host bindTimerDriver(TimerDriver td) {
		@timer = td	
	}

    public start(Handler.handle h, uint16 duration, bool repeat = true) {
		@clientTick = h
		@count = 0
		@duration = duration
		@repeat = repeat
		timer.start()		
    }

	public stop() {
		timer.stop()
		@duration = 0
	}
	
    public bool running() { 
    	return duration != 0 && timer.running()
    }
    

	public timerTick() {
		++count
		
		if (count == duration) {
			if (clientTick != 0) { clientTick() }
			count = 0
			if (!repeat) { stop() }
		}
	}
}
====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/base/pollen.time/Timer.p
>>> test source:
package pollen.time

from pollen.events import Events
from pollen.events import Event{uint8} as Event

import TimerManager

type Timer {

	Timer() {
		active = repeat = 0
	}
	
	public start(Event e, uint32 duration, bool repeat = true) {
		@e = e
		@duration = duration
		@repeat = repeat
		@active = true
		
		
	}
	
	public stop() {
		@active = false
	}
	
	public tick() {
		if (active == true) {
			# assert (elapsed < duration)
			elapsed++
			
			if (elapsed == duration) {
				if (e != 0) {
					Events.post(e)
				}
				
				if (repeat == true) {
					elapsed = 0
				} else {
					stop()
				}
			}
		}
	}

	public bool running() { return @active }

	#======================
	# Private members
	#======================
	Event e
	uint32 duration
	uint32 elapsed
	bool repeat
	bool active
}====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/examples/blink/BlinkMilliEvents.p
>>> test source:
from cc.arduino import Environment as Env

from Env import Led

from pollen.events import Event{uint8} as Event		# TODO: will eventually be just Event
from pollen.time import TimerMilli

module BlinkMilliEvents {

	value{Event} e

	toggle(Event e) { Led.toggle() }

	tick() { Env.postFromInterrupt(e) }

	pollen.run() {
		e.setHandler(toggle)
		TimerMilli.start(tick, 1000)
		Env.run()
	}
	
	pollen.reset() { Env.reset() }	
	
}====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/examples/blink/BlinkMilli.p
>>> test source:
from cc.arduino import Environment as Env

from Env import Led
from pollen.time import TimerMilli

module BlinkMilli {
      
        madams_chkArray() {
          uint8 arr[8]
          uint8 arr2d[8][2]
        }

	toggle() { Led.toggle() }

	pollen.run() {

		TimerMilli.start(toggle, 50)
		Env.GlobalInterrupts.enable()		
		while (true) { } 
	}
	
	pollen.reset() { Env.reset() }	
	
}
====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/examples/blink/Blink.p
>>> test source:
from cc.arduino import Environment as Env

from Env import Led

module Blink {

	pollen.run() {
		while (true) {
			Led.toggle()
			Env.wait(500000)
		}
	}
	
	pollen.reset() { Env.reset() }
}====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/examples/blink/Board.p
>>> test source:

#from board.arduino import Duemilanove as Hw
from board.ti import LaunchPad as Hw

from Hw import Mcu
from Mcu import GlobalInterrupts
#from Mcu import TimerMilli8BitTimer0 as TD
from Mcu import TimerMilliA0 as TD

from Hw import Led

from pollen.time import Time

composition Board {
	
	# Export composition modules
	export Led
	export Mcu

	host Board() {
		Time.bindGlobalInterrupts(GlobalInterrupts)
		Time.bindTimerDriver(TD)
	}	
}====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/test-amaret/distro.arduino.test/BoardWaitBlink.p
>>> test source:
from distro.arduino import Board
from Board import Mcu
from Board import Pin0

module BoardWaitBlink {

	pollen.run() {
		Mcu.reset()
		Pin0.makeOutput()
		
		while(true) {
			Pin0.toggle()
			Mcu.wait(50000)
		}
	}
}====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/test-amaret/distro.arduino.test/DistroWaitBlink.p
>>> test source:
from distro.arduino import Distro
from Distro import Mcu
from Distro import Pin0

module DistroWaitBlink {

	pollen.run() {
		Mcu.reset()
		Pin0.makeOutput()
		
		while(true) {
			Pin0.toggle()
			Mcu.wait(500000)
		}
	}
}====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/test-amaret/distro.arduino.test/UartHello.p
>>> test source:
from distro.arduino import Distro
from Distro import Mcu
from Distro import Uart

module UartHello {


	pollen.run() {
		Mcu.reset()
		
		---
		Uart.put(72)
		Uart.put(73)
		Uart.put(33)
		Uart.put(13)
		Uart.put(10)
		---
		
		
		Uart.put('H')
		Uart.put('e')
		Uart.put('l')
		Uart.put('l')
		Uart.put('o')
		Uart.put('!')
		Uart.put('\n')
		
	}
}====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/test-amaret/distro.ti.launchpad.test/BoardWaitBlink.p
>>> test source:
from distro.ti.launchpad import Board
from Board import Mcu
from Board import Pin0

module BoardWaitBlink {

	pollen.run() {
		Mcu.reset()
		Pin0.makeOutput()
		
		while(true) {
			Pin0.toggle()
			Mcu.wait(500000)
		}
	}
}====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/test-amaret/distro.ti.launchpad.test/DistroWaitBlink.p
>>> test source:
from distro.ti.launchpad import Distro
from Distro import Mcu
from Distro import Pin0

module DistroWaitBlink {

	pollen.run() {
		Mcu.reset()
		Pin0.makeOutput()
		
		while(true) {
			Pin0.toggle()
			Mcu.wait(50000)
		}
	}
}====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/test-amaret/mcu.atmel.atmega328p.test/TimerInterruptTest.p
>>> test source:
package mcu.atmel.atmega328p.test

from distro.arduino import Board
from Board import Mcu
from Board import Pin0
from Mcu import GlobalInterrupts
from mcu.atmel.atmega328p import TimerMilli8BitTimer0 as Timer

module TimerInterruptTest {

	uint16 count = 0

	#host TimerInterruptTest() {
	#	Timer.setHandler(blink)
	#}
	
	pollen.run() {
		Mcu.reset()
		Timer.setHandler(blink)
		Pin0.makeOutput()
		Timer.start()
		GlobalInterrupts.enable()
		while (true) { }
	}

	blink() {
		if (++count == 75) {
			Pin0.toggle()
			count = 0
		}
	}
}====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/test-amaret/mcu.ti.msp430.test/TimerMilliA0Test.p
>>> test source:
from mcu.ti.msp430g2231 import Mcu
from Mcu import P1_0 as Pin
from Mcu import GlobalInterrupts as GI

from mcu.ti.msp430 import TimerMilliA0 as TA0

module TimerMilliA0Test {

	uint32 counter = 0

	TimerMilliA0Test() {
		Mcu.reset()
		TA0.setHandler(handleISR)
		Pin.clear()
		Pin.makeOutput()
	}

	pollen.run() {
		TA0.start()
		GI.enable()
		while(true) { }		
	}
	
	handleISR() {
		if (counter++ == 500) {
			Pin.toggle()
			counter = 0
		}
	}
}====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/test-amaret/mcu.ti.msp430.test/TimerMilliTest.p
>>> test source:
---

TimerMilliTest

---

package mcu.ti.msp430g2231.test	

from mcu.ti.msp430g2231.McuLayout import GlobalInterrupts
from mcu.ti.msp430g2231.McuLayout import Mcu
from mcu.ti.msp430g2231.McuLayout import P1_0 as Pin
from mcu.ti.msp430 import TimerMilli

from pollen.events import Events
from pollen.events import Event{uint8} as Event


module TimerMilliTest {

	value{Event} e

    host TimerMilliTest() {
        Events.assignGlobalInterrupts(GlobalInterrupts)
    }

	TimerMilliTest() {
		Mcu.reset()
		e.setHandler(tick)
		Pin.clear()
		Pin.makeOutput()
	}

	pollen.run() {
		TimerMilli.start(e, 25, true)
		Events.run()
	}
			
	tick(Event t) {
		Pin.toggle()
	}
}====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/test-base/pollen.data.test/QueueCapacity.p
>>> test source:
package pollen.data.test

from pollen.data import Queue{uint8, 10} as Queue
from mcu.localhost import Write

module QueueCapacity {

	value{Queue} q
	
	pollen.run() {
		
		Write.outs("Capacity running: ")
		Write.outi(q.getCapacity())
		Write.outs("\n")
	}
}====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/test-base/pollen.data.test/QueueTest.p
>>> test source:
package pollen.data.test

from pollen.data import Queue{uint8, 10} as Queue10
from pollen.data import Queue{uint8, 22} as Queue22
from mcu.localhost import Write

module QueueTest {
	
	value{Queue22} q22
	value{Queue10} q10
		
	host QueueTest() {
		q22.setCapacity(33)
		q10.setCapacity(13)
	}	
		
	pollen.run() {
		uint8 i = 0
		
		Write.outs("q22 capacity: ")		
		Write.outi(q22.getCapacity())		
		Write.outs("\n")		
		
		Write.outs("q10 capacity: ")		
		Write.outi(q10.getCapacity())		
		Write.outs("\n")				

		for (i = 0; i < 13; i++) {
			Write.outs("e22: ")
			if (q22.enqueue(5 + i)) {
				Write.outi(5 + i)
				Write.outs(", ")
			} else {
				Write.outs("full, ")
			}
			
			Write.outi(q22.length())
			Write.outs("\n")			
		}
		
		for (i = 0; i < 13; i++) {
			uint8 x = q22.dequeue()
			Write.outs("d: ")
			Write.outi(x)
			Write.outs(", ")
			Write.outi(q22.length())
			Write.outs("\n")
		}
		
		for (i = 0; i < 13; i++) {
			Write.outs("e10: ")
			if (q10.enqueue(5 + i)) {
				Write.outi(5 + i)
				Write.outs(", ")
			} else {
				Write.outs("full, ")
			}
			
			Write.outi(q10.length())
			Write.outs("\n")			
		}
		
		for (i = 0; i < 13; i++) {
			uint8 x = q10.dequeue()
			Write.outs("d: ")
			Write.outi(x)
			Write.outs(", ")
			Write.outi(q10.length())
			Write.outs("\n")
		}
	}
}====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/test-base/pollen.events.test/DispatcherTest.p
>>> test source:
package pollen.runtime.test

---

Simple test program for the event dispatcher

---

from pollen.runtime import Dispatcher
from pollen.runtime import Event{uint8} as Event

from mcu.localhost import Write

module DispatcherTest {

	DispatcherTest() {
		e1.setPriority(1)
		e1.setHandler(func1)
		e1.setData(11)
		
		e2.setPriority(2)
		e2.setHandler(func2)
		e2.setData(22)
		
		e3.setPriority(3)
		e3.setHandler(func3)
		e3.setData(33)
	}

	pollen.run() {
		Dispatcher.post(e1)
		Dispatcher.run()
		Dispatcher.post(e2)
		Dispatcher.post(e3)
		Dispatcher.post(e2)
		Dispatcher.post(e1)
		Dispatcher.post(e3)
		Dispatcher.post(e3)
		Dispatcher.post(e2)
		Dispatcher.post(e1)

		Dispatcher.run()
		Dispatcher.run()
		Dispatcher.run()
		Dispatcher.run()
		Dispatcher.run()
		Dispatcher.run()
		Dispatcher.run()
		Dispatcher.run()
		Dispatcher.run()
		Dispatcher.run()		
	}

	value{Event} e1, e2, e3

	func1(Event id) { Write.outs("func1 "); Write.outi(id.getData()); Write.outs("\n") }

	func2(Event id) { Write.outs("func2 "); Write.outi(id.getData()); Write.outs("\n") }

	func3(Event id) { Write.outs("func3 "); Write.outi(id.getData()); Write.outs("\n") }

}
====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/test-base/pollen.events.test/EventHandlerTest.p
>>> test source:
from pollen.runtime import EventHandler{any} as EH

module EventHandlerTest {

	EH.handle h
	
	EventHandlerTest() {
		#h = func
	}
	
	func(uint8 x) {
	
	}
}====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/test-base/pollen.events.test/EventTest.p
>>> test source:

from pollen.runtime import Event{uint8} as Event

from mcu.localhost import Write

module EventTest {

	value{Event} e
		
	pollen.run() {
		e.setPriority(1)
		e.setHandler(func)
		e.setData(99)
		e.handle()
		
		e.setPriority(2)
		e.setHandler(func2)
		e.setData(23)
		e.handle()
		
		e.setPriority(3)
		e.setHandler(func)
		e.setData(12)
		e.handle()

		e.setPriority(4)
		e.setHandler(func2)
		e.setData(139)
		e.handle()
	}
	
	func(Event e) {
		Write.outs("FUNC ")	
		Write.outi(e.getData())
		Write.outs("\n")		
	}
	
	func2(Event e) {
		Write.outs("FUNC2 ")	
		Write.outi(e.getData())
		Write.outs("\n")		
	}	

}====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/test-base/pollen.test/BlinkLedDistro.p
>>> test source:
package pollen.test

---
Blink using a busy wait 
---

#from distro.ti.launchpad import Distro
from distro.arduino import Distro

from Distro import Mcu
from Distro import Led

module BlinkLed {


    pollen.run() {
        
    	Mcu.reset()

		while (true) {

            Led.toggle()
			Mcu.wait(500000)
		}
	}
}
====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/test-base/pollen.test/BlinkLed.p
>>> test source:
package pollen.test

---
Blink using a busy wait 
---

#from distro.ti.launchpad import Board
from distro.arduino import Board

from Board import Mcu
from Board import Led

module BlinkLed {

    pollen.reset() {
        Mcu.reset() 
    }

    pollen.run() {
        
        while (true) {

            Led.toggle()
            Mcu.wait(500000)
        }
    }
}
====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/test-base/pollen.test/Blink.p
>>> test source:
package pollen.test

---
Blink using a busy wait 
---

from distro.ti.launchpad import Board
#from distro.arduino import Board

from Board import Mcu
from Board import Pin0 as Pin

module Blink {


	pollen.run() {
        
		Mcu.reset()
		Pin.clear()
		Pin.makeOutput()

		while (true) {
			Pin.toggle()
			Mcu.wait(500000)
		}
	}
}
====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/test-base/pollen.test/Comp1.p
>>> test source:

from mcu.ti.msp430g2231.McuLayout import Mcu
from mcu.ti.msp430g2231.McuLayout import P1_0
from mcu.ti.msp430g2231.McuLayout import Wait

composition Comp1 {

    export Mcu
    export P1_0 
    export Wait
    export Mcu.reset
    export Wait.us
    export P1_0.clear
    export P1_0.makeOutput
    export P1_0.toggle
}====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/test-base/pollen.test/Comp2.p
>>> test source:

from mcu.ti.msp430g2231.McuLayout import Mcu
from mcu.ti.msp430g2231.McuLayout import P1_0
from mcu.ti.msp430g2231.McuLayout import Wait

import Led

composition Comp2 {

    export Mcu
    export P1_0 
    export Wait
    export Mcu.reset
    export Wait.us
    export P1_0.clear
    export P1_0.makeOutput
    export P1_0.toggle
}====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/test-base/pollen.test/CompBusyBlink.p
>>> test source:
---

Blink an LED using events and the event dispatcher

---

package pollen.test

from distro.ti.launchpad import Distro
from Distro import Mcu
from Distro import Pin
from Distro import Wait

from pollen.events import Event{uint8} as Event

module CompBusyBlink {

	pollen.run() {
        Mcu.reset()
        Pin.clear()
        Pin.makeOutput()
        
        while (true) {
            Pin.toggle()
            Wait.us(50000)
        }
	}
}====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/test-base/pollen.test/CompTest1.p
>>> test source:
---
Test: composition can have functions called on it
---

import Comp

module CompTest1 {

    pollen.run() {
        Comp.reset()
        Comp.clear()
        Comp.makeOutput()
        
        while(true) {
            Comp.toggle()
            Comp.us(20000)
        }
    }
}====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/test-base/pollen.test/CompTest2.p
>>> test source:
---
Test: composition binds a module interface member
---

import Comp

module CompTest1 {

    pollen.run() {
        Comp.reset()
        Comp.clear()
        Comp.makeOutput()
        
        while(true) {
            Comp.toggle()
            Comp.us(20000)
        }
    }
}====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/test-base/pollen.test/DistroTest.p
>>> test source:
from distro.ti.launchpad import Distro
from Distro import Mcu
from Distro import Pin
from Distro import Wait

module DistroTest {

    pollen.run() {
        Mcu.reset()
        Pin.makeOutput()
        
        while(true) {
            Pin.toggle()
            Wait.us(500000)
        }
    }
}====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/test-base/pollen.test/EventBlinkLong.p
>>> test source:
---

Blink an LED using events and the event dispatcher

---

package pollen.test

from distro.ti.launchpad import Board
from Board import GlobalInterrupts
from Board import Mcu
from Board import Pin
from Board import TimerMilli

from pollen.events import Dispatcher
from pollen.events import Event{uint8} as Event

module EventBlink {

	value{Event} e			# will be: Event e(toggle)

    host EventBlink() {
        Dispatcher.assignGlobalInterrupts(GlobalInterrupts)
    }

	pollen.run() {
		e.setHandler(toggle)
        TimerMilli.start(e, 250, true)
		Dispatcher.run()
	}
	
	toggle(Event e) {
        Pin.toggle()
	}
}====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/test-base/pollen.test/EventBlink.p
>>> test source:
---

Blink an LED using events and the event dispatcher

---

package pollen.test

from distro.ti.launchpad import Distro
from Distro import Mcu
from Distro import Pin
from Distro import TimerMilli

from pollen.events import Events
from pollen.events import Event{uint8} as Event

module EventBlink {

	value{Event} e			# will be: Event e(toggle) or Events.createEvent()

    pollen.reset() {
        Mcu.reset()
        Pin.makeOutput()
        Pin.clear()
		e.setHandler(toggle)
    }

	pollen.run() {
        TimerMilli.start(e, 250, true)
		Dispatcher.run()
	}
	
	toggle(Event e) {
        Pin.toggle()
	}

}====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/test-base/pollen.test/GpioForward.p
>>> test source:
from pollen.interfaces import Gpio

from mcu.atmel.atmega328p import PD5

module FancyPD5 implements Gpio {
    
 
    public bool get() { 
    
        # do my own stuff
        
        x = PD5.get()
        
        # do something with x
            
        return x
    }
        
}====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/test-base/pollen.test/Led.p
>>> test source:
from mcu.ti.msp430g2231.McuLayout import Mcu
from mcu.ti.msp430g2231.McuLayout import P1_0 as Pin
from mcu.ti.msp430g2231.McuLayout import Wait
from pollen.interfaces import Gpio

module Led {

    host Gpio LedPin
    
    public host bindPin(Gpio p) {
        LedPin = p
    }
    
    public toggle() { LedPin.toggle() }
    
    public on() { LedPin.set() }

    public off() { LedPin.clear() }
    
    public bool isOn() { return LedPin.get() }

    pollen.run() {
        Mcu.reset()
        LedPin.clear()
        LedPin.makeOutput()
    
        while (true) {
            LedPin.toggle()
            Wait.us(500000)
        }
    }
    
    host Led() {
    	bindPin(Pin)
    }

}====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/test-base/pollen.time.test/TimerManagerTest.p
>>> test source:

from distro.arduino import Distro
from Distro import Mcu

from pollen.time import TimerManager

module TimerManagerTest {

	value{TimerManager.Timer} t

	host TimerManagerTest() {
		t.init()
	}

	pollen.run() {
		Mcu.reset()		

		while(true) {
		
		}
	}
}====================================
>>> test name:
/home/lucidbee/Documents/MeganAdams-Pollen/MeganAdams-Pollen/pollen-base/pollen-base/test-base/pollen.time.test/TimerTest.p
>>> test source:

from pollen.time import Timer


module TimerTest {

	value{Timer} t
	
	pollen.run() {
	
	}
}====================================
