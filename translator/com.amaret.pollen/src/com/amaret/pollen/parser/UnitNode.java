package com.amaret.pollen.parser;

import java.util.ArrayList;
import java.util.Collection;
import java.util.EnumSet;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.antlr.runtime.tree.Tree;

import com.amaret.pollen.parser.DeclNode.Fcn;
import com.amaret.pollen.parser.DeclNode.ITypeKind;

public class UnitNode extends BaseNode implements ISymbolNode, IScope, IUnitWrapper, DeclNode.ITypeKind {
	
    static private final int IMPORTS = 1;
    static private final int PKGNAME = 0;
    static private final int INJECT1 = 2;
    static private final int UNIT = 3;
    static private final int INJECT2 = 4;
     
    
    // Each name can map to multiple DeclNode.Fcn nodes, for overloads.
    private Map<String,List<DeclNode.Fcn>> fcnMap = new HashMap<String,List<DeclNode.Fcn>>();
    // A client is a unit that imports this unit.
    private Map<String,UnitNode> clientMap = new HashMap<String,UnitNode>();
    private List<ExportNode> exportList = new ArrayList<ExportNode>();
    private DeclNode.Usr unitType;
    private IScope definingScope;
	private IScope enclosingScope;
	private int errorCount;
    private String filePath;
    private EnumSet<Flags> flags = EnumSet.noneOf(Flags.class);
	private Map<String,Integer> exprConstStringTable = new HashMap<String,Integer>();   
    private Map<String, ImportNode> importMap = new HashMap<String, ImportNode>();
	class UnitHashMap<K,V> extends HashMap<K,V> {
		/**
		 * 
		 */
		private static final long serialVersionUID = 1L;

		public V put(K k,V v) {
			V rtn = super.put(k, v);
			if (rtn != null) {
				if (k.toString().equals("Core"))
					k.toString();
				ParseUnit.internalMsg("Collision detected for key " + k.toString());
			}
			return rtn;
		}		
	}
    private Map<String,SymbolEntry> symbolTable = new UnitHashMap<String,SymbolEntry>();
    private Cat typeCat = null;
    private boolean hostScope = false;

	/*
	 * true if this unit was generated by the parser when called on a meta type 
	 * with an import which had (possibly default) meta arguments.
	 */
	public boolean isGeneratedMetaInstance() {
		if (!isMeta())
			return false;
		String fname = this.getFileName().substring(0,getFileName().lastIndexOf('.'));  //x.y.z.p => x.y.z
		fname = fname.substring(fname.lastIndexOf('.')+1);
		if (!(fname.equals(this.getName().getText())))
			return true;
		return false;
		
	}

	public List<ExportNode> getExportList() {
		return exportList;
	}

	public Map<String, List<DeclNode.Fcn>> getFcnMap() {
		return fcnMap;
	}
	
	/**
	 * Add Fcn Node to Map. Handle overloaded function names.
	 * @param name
	 * @param fcn
	 */
	public void addFcn(String name, DeclNode.Fcn fcn) {
		if (!fcnMap.containsKey(name)) {
			List<DeclNode.Fcn> fcnEntry = new ArrayList<DeclNode.Fcn>();
			fcnEntry.add(fcn);
			fcnMap.put(name, fcnEntry);
			return;
		}
		fcnMap.get(name).add(fcn);		
	}
		
	public DeclNode.Usr getUnitType() {
		if (unitType == null)
			unitType =  ((DeclNode.Usr) getChild(UNIT));
		return unitType;
	}
	
	public List<DeclNode> getFeatures() {		
		return this.getUnitType().getFeatures();
    }

    
    UnitNode(int ttype, String ttext) {
      	this.token = new Atom(ttype, ttext);
    }
	/**
	 * This unit is imported by another unit 'u'
	 * @param u
	 */
    void addClient(UnitNode u) {
        clientMap.put(u.getQualName(), u);
    }
    
    void addString(String s) {
        if (!exprConstStringTable.containsKey(s)) {
            exprConstStringTable.put(s, exprConstStringTable.size());
        }
    }
    
    
    @Override
    public boolean defineSymbol(Atom name, ISymbolNode node) {
        if (resolveSymbol(name) != null) {
            return false;
        }
	    symbolTable.put(name.getText(), new SymbolEntry(this, node));
	    node.setDefiningScope(this);
	    return true;
    }
    
    public SymbolEntry putSymbol(String name, SymbolEntry se) {
    	return symbolTable.put(name, se);
    }
    
    void destruct() {
        fcnMap = null;
        clientMap = null;
        exportList = null;
        definingScope = null;;
        enclosingScope = null;
        exprConstStringTable = null;
        symbolTable = null;
        typeCat = null;
    }
    public int findString(String s) {
        Integer id = exprConstStringTable.get(s);
        return id != null ? id : -1;
    }
    
    public UnitNode getContainingUnit() {
    	if (this.getUnitType().getContainingType() != null)
    		return this.getUnitType().getContainingType().getUnit();
    	return null;
    }
    /**
     * 
     * @return unit for 'implements' clause
     */
    public UnitNode getImplementedUnit() {
    	if (this.getUnitType().getImplementedType() != null)
    		return this.getUnitType().getImplementedType().getUnit();
    	return null;
    }
    
    public Collection<UnitNode> getClients() {
        return clientMap.values();
    }

    @SuppressWarnings("unchecked")
    public List<ExprNode.Inject> getInject1() {
    	return ((ListNode<ExprNode.Inject>) getChild(INJECT1)).getElems();
    }
    
    @SuppressWarnings("unchecked")
    public List<ExprNode.Inject> getInject2() {
    	return ((ListNode<ExprNode.Inject>) getChild(INJECT2)).getElems();
    }
    
    @Override
    public IScope getDefiningScope() {
        return definingScope;
    }
            
    @Override
    public IScope getEnclosingScope() {
        return enclosingScope;
    }
    
    @Override
    public Set<Map.Entry<String,SymbolEntry>> getEntrySet() {
        return symbolTable.entrySet();
    }

    public int getErrorCount() {
        return errorCount;
    }
    
    @SuppressWarnings("unchecked")
    public List<ImportNode> getImports() {
        return ((ListNode<ImportNode>)getChild(IMPORTS)).getElems();
    }
    
    public String getFilePath() {
        return filePath;
    }
    
    @Override
    public Atom getName() {
    	return this.getUnitType().getName();
    }
    
    public Atom getPkgName() {
        return ((BaseNode) getChild(PKGNAME)).getAtom();
    }
    
    public String getQualName() {
        return "" + getPkgName() + '.' + getName();
    }
    
    @Override
    public String getScopeName() {
    	return getQualName();
    }

    public Set<Map.Entry<String,Integer>> getStrings() {
        return exprConstStringTable.entrySet();
    }
    
    public UnitNode getUnit() {
        return this;
    }
    
    @Override
    public Cat getTypeCat() {
        if (typeCat == null) {
            typeCat = Cat.fromSymbolNode(this, this.getDefiningScope());
        }
        return typeCat;
    }

    
    void incErrorCount() {
        this.errorCount += 1;
    }

    void init() {
    	filePath = ParseUnit.current().getCurrPath();
    }
    
    public boolean isHostScope() {
    	if (isHost())
    		return true;
		return hostScope;
    }
	public void setHostScope(boolean hostScope) {
		this.hostScope = hostScope;
	}   
	/**
	 * 
	 * @return true if not a composition
	 */
    public boolean isTarget() {
    	return !isHost();
    }
    public boolean isHost() {
    	if (flags.contains(Flags.COMPOSITION))
    		return true;
    	return false;
    }
   public boolean isEnum() {
   	if (flags.contains(Flags.ENUM))
   		return true;
   	return false;
   }       
    public boolean isModule() {
    	if (flags.contains(Flags.MODULE))
    		return true;
    	return false;
    }       
    public boolean isProtocol() {
    	if (flags.contains(Flags.PROTOCOL))
    		return true;
    	return false;
    }
    public boolean isComposition() {
    	if (flags.contains(Flags.COMPOSITION))
    		return true;
    	return false;
    }
    public boolean isClass() {
    	if (flags.contains(Flags.CLASS))
    		return true;
    	return false;
    }
    /**
     * 
     * @return true if this unit is a meta instance (instantiated with meta parms).
     */
    public boolean isMeta() {
    	if (flags.contains(Flags.META))
    		return true;
    	return false;
    }

    /**
     * True if this is a deferred instantiation for a meta type
     * (for which no code will be generated).
     * Used only for name resolution, etc.
     * @return Flags.VOID_INSTANCE
     */
    public boolean isVoid() { 
    	if (flags.contains(Flags.VOID_INSTANCE))
    		return true;
    	return false;
    }

    public List<DeclNode.Fcn> lookupFcn(String name) {
        return fcnMap.get(name);
    }
    
    @Override
    public SymbolEntry lookupName(String name) {
    	
    	SymbolEntry result = symbolTable.get(name);
        if (result != null) {
            return result;
        }
        
        if (name.indexOf(".") != -1) {
        	// qualified names ('x.y.z') need chained lookups, one qualifier at a time.
        	IScope sc = this;
        	String qualifier = name.substring(0, name.indexOf("."));
        	name = name.substring(name.indexOf(".")+1, name.length());

        	while (true) {
        		if (result != null && result.node() instanceof IScope)
        			result = ((IScope) result.node()).lookupName(qualifier);
        		else 
        			result = sc.lookupName(qualifier);
        		
        		if (result == null) 
        			break;
        		        			
        		if (name.isEmpty())
        			return result;
        		sc = result.scope();
        		if (name.indexOf(".") == -1) {
        			qualifier = name;
        			name = "";
        		}
        		else {
        			qualifier = name.substring(0, name.indexOf("."));
                	name = name.substring(name.indexOf(".")+1, name.length());
        		}      		      		
        	}
        }

        return null;
    }
    @Override
    public SymbolEntry lookupName(String name, boolean chkHostScope) {
    	
    	SymbolEntry result = symbolTable.get(name);
        if (result != null) {
            return result;
        }
        
        if (name.indexOf(".") != -1) {
        	// qualified names ('x.y.z') need chained lookups, one qualifier at a time.
        	IScope sc = this;
        	String qualifier = name.substring(0, name.indexOf("."));
        	name = name.substring(name.indexOf(".")+1, name.length());

        	while (true) {
        		if (result != null && result.node() instanceof IScope)
        			result = ((IScope) result.node()).lookupName(qualifier, chkHostScope);
        		else 
        			result = sc.lookupName(qualifier, chkHostScope);
        		
        		
        		if (result == null)
        			break;
        		if (name.isEmpty()) {
        			return result;
        		}
        		sc = result.derefScope(false);
        		//sc = result.scope();
        		if (name.indexOf(".") == -1) {
        			qualifier = name;
        			name = "";
        		}
        		else {
        			qualifier = name.substring(0, name.indexOf("."));
                	name = name.substring(name.indexOf(".")+1, name.length());
        		}      		      		
        	}
        }

        return null;

    }
    
    @Override
    protected boolean pass1Begin() {
    	//System.out.println("**UnitNode " + this.getQualName() + " pass1Begin()");
    	flags = unitType.getFlags();
    	ParseUnit currUnit = ParseUnit.current();               
        currUnit.getSymbolTable().enterScope(this);    	
        //this.importSymbols(); // moved to pass1End() because imports/exports must be handled first.
        return true;
    }
    
    private List<String> importedUnits = new ArrayList<String>();
    private List<String> importedFrom = new ArrayList<String>();
    /**
     * Import all the units that are exported by the units this unit imports.
     * A variety of cases:
     * If this unit is not an exported unit and is a composition, import
     * its symbols into this units symbol table. Output message for any collision.
     * For modules, propagate the export filter. 
     * If this unit has a base type, insert the base type imports into this
     * units symbol table. 
     */
    private void importSymbols() {
    	// 
    	
    	//boolean dbg = true;
    	boolean dbg = false;
//    	if (this.getQualName().equals("test44.BlinkEnvPin"))
//    		dbg = true;

    	
    	ParseUnit.setDebugMode(dbg);
    	if (dbg) {
    		ParseUnit.current().reportError(this, "\n**************importSymbols() for unit " + this.getQualName() + "**********************" );
    	}

    	UnitNode curUnit = this;  	
    	SymbolEntry newSymbol;
    	next:
    		for (ImportNode imp : curUnit.getImports()) {
    			UnitNode impUnit = imp.getUnit();
    			    			
    			importedUnits.add(imp.getUnitName().getText());
    			String frm = imp.getFrom().getText();
    			importedFrom.add(frm);
    			
    			if (dbg)
    				ParseUnit.current().reportError(curUnit, "START import " + imp.getQualName());
   			
    			if (impUnit == null) {
    				if (dbg)
    					ParseUnit.current().reportError(curUnit, "Import " + imp.getQualName() + " has unit = NULL");   			
    			}
    			else 
    				if (!imp.isExport() && impUnit != null && imp.isComposition()) {
    					
    					for (ImportNode iun : impUnit.getImports()) {
    							for (Map.Entry<String, SymbolEntry> e : iun.getExportFcns().entrySet()) {
    								if (dbg) {
    									System.out.println("** importSymbols(): Insert " + e.getKey() + " into symtab from scope " + iun.getName());
    								}
    								SymbolEntry se = this.putSymbol(e.getKey(), e.getValue());		
    								if (se != null && se != e.getValue()) {
    									ParseUnit.current().reportError(ParseUnit.current().getCurrUnitNode(), "Import of composition '" + imp.getName().getText() + "' results in multiple objects being referenced with the name '" + e.getKey() + "'.");
    								}
    							}
    					}

    					for (Map.Entry<String, SymbolEntry> importedSym : impUnit.symbolTable.entrySet()) {
    						
    						ISymbolNode importedNode = importedSym.getValue().node();
    						if (dbg) {
    							ParseUnit.current().reportError(curUnit, "check for export of symbol '" + importedSym.getKey() + "' via import " + imp.getQualName() + " into scope " + curUnit.getScopeName());
    						}

    						if (importedNode instanceof ImportNode && ((ImportNode) importedNode).isComposition()) {
    							// If I can get an import that will give me the module definition (to have access to full function set
    							// for lookups) then make a copy of it and propagate the current exports to the copy. 
    							ImportNode save = (ImportNode) importedNode;
    							importedNode = lookupModuleDefn(importedNode);
    							if (save != importedNode) {
    								importedNode = ((ImportNode) importedNode).copy();
    								((ImportNode) importedNode).setExport(save.isExport());
    								((ImportNode) importedNode).setExportFcns(save.getExportFcns());
    							}
    						}

    						if (importedNode instanceof UnitNode)
    							importedNode = ((UnitNode) importedNode).getUnitType();

    						if (importedNode instanceof DeclNode && !((DeclNode) importedNode).isPublic()) {
    							continue;
    						}

    						if (importedNode instanceof DeclNode.Fcn ) {
    							continue;
    						}

    						if (importedNode instanceof ImportNode && !((ImportNode) importedNode).isExport()) {
    							continue;
    						}

    						if (importedNode instanceof ExportNode) // e.g. not an import or function
    							continue;

    						newSymbol = new SymbolEntry(importedNode.getDefiningScope(), importedNode);


    						if (dbg) {
    							ParseUnit.current().reportError(curUnit, "  import exported symbol '" 
    									+ importedSym.getKey() + "' via import " + imp.getQualName() 
    									+ " into scope " + curUnit.getScopeName());
    						}
    						SymbolEntry curr=null, s=null;
    						if (dbg)
    							isDuplicateSymbol(newSymbol, importedSym);
//    						
//    						String f = imp.getUnit().getPkgName().getText();
//    						ImportNode inew = (ImportNode) newSymbol.node();
//    						String inewStr = "from " + inew.getFrom() + " import " + inew.getUnitName() + " As " + inew.getAs() + ", " + inew.getName() ;
//    						System.out.println("newSymbol: " + inewStr);
//    						String impStr = "from " + imp.getFrom() + " import " + imp.getUnitName() + " As " + imp.getAs() + ", " + imp.getName() ;
//    						System.out.println("import: " + impStr + ", pkg " + f);
    						String key;
    						
    						// Is imp an import of a composition or a module from a composition?
    						// (1) 'import compos' or (2) 'from compos import m' 
    						// It matters for the key for symtab insert.
    						
    						if (!(imp.getUnit().getPkgName().getText().equals(imp.getFrom().getText())))
    							key = imp.getName().getText(); // (2): key is from module in (2)
    						else
    							key = importedSym.getKey(); // (1): key is from module imported as a result of (1)
    							
    						    						
    						curr = symbolTable.put(key, newSymbol);  
    						if (curr != null && curr.node() instanceof ImportNode
    								&& ((ImportNode) curr.node()).isExport()) {
    							((ImportNode) newSymbol.node()).getExportFcns().putAll(((ImportNode) curr.node()).getExportFcns());
    							((ImportNode) newSymbol.node()).setExport(((ImportNode) curr.node()).isExport());

    						}
    						if (curr != null && dbg)  {
    							String i = "";
    							if (curr.node() instanceof ImportNode) {
    								ImportNode origi = (ImportNode) curr.node();
    								i =  "ImportNode ";
    								i += origi.isExport() ? "(isExport TRUE) ": "";   							
    							}

    							ParseUnit.current().reportError(curUnit, "  and replace SymbolEntry for " + i + "'" 
    									+ curr.scope().getScopeName() + "." + curr.node().getName().getText() + "'" 
    									+ " with export '" + importedSym.getKey() + "'");

    						}
    						if (importedSym.getKey().equals(imp.getUnitName().getText()) && !importedSym.getKey().equals(imp.getName().getText())) {

    							s = symbolTable.put(imp.getName().getText(), newSymbol);	// 	the 'as' name
    							if (dbg) {
    								ParseUnit.current().reportError(curUnit, "enter " + importedSym.getKey() + " SymbolEntry with import 'as' name " + imp.getName());
    								if (s != null) {
    									ParseUnit.current().reportError(curUnit, "  and replace SymbolEntry for " + imp.getQualName() + " (" + imp.getName().getText() + ") "+ " with SymbolEntry for export " + importedSym.getKey());
    								}
    							}
    						}
    					}

    				}
    		}
    	
    	putBaseUnitImports(curUnit);

    	ParseUnit.setDebugMode(false);
    }

	/**
	 * For lookups, imports for base unit are inserted into the symtab for derived unit.
	 * They will be copied and updated to have the current export filter. 
	 * @param curUnit
	 */
	private void putBaseUnitImports(UnitNode curUnit) {
		SymbolEntry newSymbol;
		// Imports for base types are inserted into the derived type symbol table. 
    	if (this.getUnitType().getBaseType() != null) {
    		UnitNode baseU = this.getUnitType().getBaseType().getUnit();

    		List<SymbolEntry> baseImpList = new ArrayList<SymbolEntry>();
    		for (Map.Entry<String, SymbolEntry> baseImportSym : baseU.symbolTable.entrySet()) {					
    			ISymbolNode baseImportNode = baseImportSym.getValue().node();
    			if (baseImportNode instanceof ImportNode) {
    				//if (symbolTable.get(baseImportSym.getKey()) == null) {
    					baseImpList.add(baseImportSym.getValue());    					
    				//}						
    			}
    		}
    		if (baseImpList.size() > 0) {
    			// Get the imports which bring in the base unit (there can be more than one) and propagate their exports to 
    			// the appropriate import nodes of the base unit, which will be copied to the derived unit.
    			for (ImportNode imp : curUnit.getImports()) {
    				if (imp.getUnit() == baseU) {
    					for (Map.Entry<String, List<SymbolEntry>> sce : imp.getScopesExportFcns().entrySet()) {
    						for (SymbolEntry baseSym : baseImpList) {   
    							newSymbol = new SymbolEntry(baseSym.node().getDefiningScope(), ((ImportNode) baseSym.node()).copy());
    							for (Map.Entry<String, SymbolEntry> baseExpFcnEntry : ((ImportNode) baseSym.node()).getExportFcns().entrySet()) {
        							if (sce.getKey().equals(baseExpFcnEntry.getValue().node().getDefiningScope().getScopeName())) {
        								// scope name of derived unit export function is the same as scope name of base export fcn   
        								for (SymbolEntry es : sce.getValue()) {
        									((ImportNode) newSymbol.node()).getExportFcns().put(es.node().getName().getText(), es);
        								}
        							}

    							}
    							
    							symbolTable.put(newSymbol.node().getName().getText(), newSymbol);    							
    						}
    						
    					}
    				}
    			}
    			
    		}

    	}
	}

    public ImportNode getImportByName(String n) {
    	if (importMap.isEmpty()) {
    		for (ImportNode imp : this.getImports()) {
    			importMap.put(imp.getName().getText(), imp);
    			importMap.put(imp.getUnitName().getText(), imp);    			
    		}    		
    	}
    	return importMap.get(n);    	
    }
    /**
     * @return all the exported functions of all the imports
     */
    public Map<String, SymbolEntry> getFcnsExportedByImports() {
    	
    	Map<String, SymbolEntry> fcns = new HashMap<String, SymbolEntry>();
		for (ImportNode imp : this.getImports()) {
			if (!imp.isExport())
				continue;
			if (imp.getExportFcns().isEmpty())
				continue;
			for (Map.Entry<String, SymbolEntry> e : imp.getExportFcns().entrySet()) {
				fcns.put(e.getKey(), e.getValue());				
			}
		}
		return fcns; 	
    }
    
    /**
     * Look through the exportedFcn lists of the Imports for a match
     * on fname.
     * Note when there are name collisions (Mcu.cycle, Board.cycle) and the composition
     * containing these exports is imported as a whole (not modules from the composition) 
     * then the names can lose their disambiguation. The first encountered is returned.
     * Uncalled.
     * @param fname
     * @return fname SymbolEntry
     */
    public SymbolEntry lookupExportedFcn(String fname) {
		for (ImportNode imp : this.getImports()) {
			if (!imp.isExport())
				continue;
			if (imp.getExportFcns().isEmpty())
				continue;
			if (imp.getExportFcns().get(fname) == null)
				continue;
			return imp.getExportFcns().get(fname);
		}
		return null;   	
    }
    /**
     * Look through the exportedFcn lists of this units Imports for a match
     * on fname
     * @param fname
     * @param i the fail to match return value
     * @return the ImportNode which (first) matched
     */
    public ImportNode lookupImportForExport(String fname, ImportNode i) {
		for (ImportNode imp : this.getImports()) {
			if (!imp.isExport())
				continue;
			if (imp.getExportFcns().isEmpty())
				continue;
			if (imp.getExportFcns().get(fname) == null)
				continue;
			return imp;
		}
		return i;   	
    }


	/**
	 * For imports of composition modules, such as 'm':
	 *   F1.p: 'from compos import m' 
	 *              export m.foo
	 *   F2.p  'from F1 import m as p'
	 *              export p.bar
	 *  F3.p   'from F2 import p as q'
	 *  ...etc
	 * drill into the import sequence to find the import 
	 * which has the original module defn for m
	 * (where the function is).
	 * @param importedNode
	 * @return importedNode (to original module definition)
	 */
	public ISymbolNode lookupModuleDefn(ISymbolNode importedNode) {
		// drill down to something real, a non-composition
		ImportNode i = (ImportNode) importedNode;
		SymbolEntry is = null;
		while (i.getUnit() != null && i.isComposition()) {
			is = i.getUnit().lookupName(i.getUnitName().getText());
			if (is == null || !(is.node() instanceof ImportNode)) {
				is = null;
				break;
			}
			
			i = (ImportNode) is.node();
			if (i.getUnit() == null)
				ParseUnit.internalMsg(i.getName() + " has null unit");
		} 
		if (is instanceof ITypeKind && ((ITypeKind) is).isComposition())
			ParseUnit.internalMsg(i.getName() + " is composition type");
		if (is == null)
			return importedNode; // no change
		return is.node();
	}

	/**
	 * @param newSymbol
	 * @param importedSym
	 */
	private void isDuplicateSymbol(SymbolEntry newSymbol,
			Map.Entry<String, SymbolEntry> importedSym) {
		if (symbolTable.get(importedSym.getKey()) != null) {
			String symName = importedSym.getKey();
			String oldSc = symbolTable.get(importedSym.getKey()).node().getDefiningScope().getScopeName();
			String newSc = newSymbol.scope().getScopeName();
			ParseUnit.current().reportError(this, "  replacing symbol '" + symName + "' in scope " + oldSc + " with same name symbol in scope " + newSc);
		}
	}

    
    @Override
    protected void pass1End() {
    	this.importSymbols();
        ParseUnit.current().getSymbolTable().leaveScope();
    }
    @Override
    protected boolean pass2Begin() {
        ParseUnit.current().getSymbolTable().enterScope(this);
        return true;
    }
    
    @Override
    protected void pass2End() {
        ParseUnit.current().getSymbolTable().leaveScope();
    }

    @Override
    public void replaceSymbol(Atom name, ISymbolNode node) {
    	
        SymbolEntry r = symbolTable.put(name.getText(), new SymbolEntry(definingScope, node));
        boolean dbg = false;
        if (r != null) {
        	dbg = true;
        }
        node.setDefiningScope(definingScope);
    }

    @Override
    public SymbolEntry resolveSymbol(Atom name) {
    	SymbolEntry s = lookupName(name.getText());
    	return (s == null) ? lookupName(name.getText(), true) : s;
    }

    @Override
    public void setDefiningScope(IScope scope) {
        definingScope = scope;
    }

    @Override
    public void setEnclosingScope(IScope scope) {
        enclosingScope = scope;
    }

    void setErrorCount(int errorCount) {
        this.errorCount = errorCount;
    }
        
    void setFilePath(String filePath) {
        this.filePath = filePath;
    }
    
    @Override
    public String toString() {
    	return token.getText() + flags;
    }


	@Override
	public boolean isReady() {
		return true;
	}

}
